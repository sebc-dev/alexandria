---
phase: 12-performance-quick-wins
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker/postgres/postgresql.conf
  - docker-compose.yml
  - src/main/resources/application.yml
autonomous: true
requirements:
  - PERF-02
  - PERF-03

must_haves:
  truths:
    - "PostgreSQL starts with tuned shared_buffers=2GB, maintenance_work_mem=1GB, JIT off, and ef_search=100"
    - "HikariCP pool is sized at 10 connections with 5s connection timeout and 30s leak detection"
  artifacts:
    - path: "docker/postgres/postgresql.conf"
      provides: "PostgreSQL override config for RAG workload tuning"
      contains: "shared_buffers = 2GB"
    - path: "docker-compose.yml"
      provides: "Volume mount for postgresql.conf"
      contains: "docker/postgres/postgresql.conf"
    - path: "src/main/resources/application.yml"
      provides: "HikariCP pool config for virtual threads"
      contains: "maximum-pool-size: 10"
  key_links:
    - from: "docker-compose.yml"
      to: "docker/postgres/postgresql.conf"
      via: "volume mount into postgres container"
      pattern: "postgresql\\.conf"
---

<objective>
Configure PostgreSQL and HikariCP for the Alexandria RAG workload.

Purpose: Reduce query latency and resource contention by tuning PostgreSQL memory allocation, disabling JIT, setting HNSW ef_search globally, and sizing HikariCP for virtual threads.
Output: PostgreSQL config file mounted via docker-compose, HikariCP properties in application.yml.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docker-compose.yml
@src/main/resources/application.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL config and mount via docker-compose</name>
  <files>docker/postgres/postgresql.conf, docker-compose.yml</files>
  <action>
Create the directory `docker/postgres/` and a `postgresql.conf` override file with ONLY the tuned parameters (PG defaults apply for everything else). Per user decisions:

```
# Alexandria RAG workload tuning (4 CPU cores, ~6GB allocated to PG)
shared_buffers = 2GB
maintenance_work_mem = 1GB
effective_cache_size = 4GB
work_mem = 64MB
jit = off

# HNSW index tuning — global ef_search for pgvector
hnsw.ef_search = 100
```

Choose `effective_cache_size = 4GB` (reasonable for 6GB PG allocation, OS caches the rest of 24GB RAM) and `work_mem = 64MB` (per user discretion — generous for sort/hash operations in a low-concurrency system).

In `docker-compose.yml`, add a volume mount to the postgres service:
```yaml
volumes:
  - alexandria-data:/var/lib/postgresql/data
  - ./docker/postgres/postgresql.conf:/etc/postgresql/postgresql.conf:ro
```

And add a `command` to the postgres service to load the custom config:
```yaml
command: ["postgres", "-c", "config_file=/etc/postgresql/postgresql.conf"]
```

Note: The `command` approach loads our override file as the main config. Since we only specify tuned params, PostgreSQL uses its compiled-in defaults for everything else. This is the standard Docker approach for custom postgres configs.
  </action>
  <verify>
Run `docker compose config` to validate the compose file syntax. Verify the volume mount and command are present in the output. Check that `docker/postgres/postgresql.conf` exists and contains the expected parameters.
  </verify>
  <done>docker-compose.yml mounts postgresql.conf into postgres container with custom command, and postgresql.conf contains shared_buffers=2GB, maintenance_work_mem=1GB, jit=off, hnsw.ef_search=100.</done>
</task>

<task type="auto">
  <name>Task 2: Configure HikariCP pool for virtual threads</name>
  <files>src/main/resources/application.yml</files>
  <action>
Add HikariCP configuration under the `spring.datasource` section in application.yml. Per user decisions:

```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 10
      connection-timeout: 5000
      leak-detection-threshold: 30000
```

- `maximum-pool-size: 10` — conservative for virtual threads (small pool shared efficiently)
- `connection-timeout: 5000` — 5 seconds, fail fast for interactive MCP usage
- `leak-detection-threshold: 30000` — 30 seconds, log warning for held connections
- `max-lifetime` and `idle-timeout` left at HikariCP defaults (30min / 10min) per user decision

Do NOT change any other existing properties. Add the `hikari` block directly under the existing `datasource` section.
  </action>
  <verify>
Run `grep -A5 'hikari' src/main/resources/application.yml` to confirm the properties are present. Run `./quality.sh test` to ensure the application context still loads correctly in tests.
  </verify>
  <done>application.yml contains HikariCP pool-size=10, connection-timeout=5000ms, leak-detection=30000ms under spring.datasource.hikari.</done>
</task>

</tasks>

<verification>
1. `docker compose config` produces valid output with postgresql.conf volume mount and postgres command
2. `docker/postgres/postgresql.conf` contains: shared_buffers=2GB, maintenance_work_mem=1GB, jit=off, hnsw.ef_search=100
3. `src/main/resources/application.yml` contains hikari pool configuration
4. `./quality.sh test` passes (existing tests unaffected by config changes)
</verification>

<success_criteria>
- PostgreSQL config file exists at docker/postgres/postgresql.conf with all tuned parameters
- docker-compose.yml mounts the config file and passes it to postgres via command
- HikariCP pool is configured with 10 connections, 5s timeout, 30s leak detection
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-performance-quick-wins/12-01-SUMMARY.md`
</output>
