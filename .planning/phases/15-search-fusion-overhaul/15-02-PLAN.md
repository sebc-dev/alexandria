---
phase: 15-search-fusion-overhaul
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/main/java/dev/alexandria/search/SearchService.java
  - src/test/java/dev/alexandria/search/SearchServiceTest.java
  - src/main/java/dev/alexandria/search/SearchRequest.java
  - src/test/java/dev/alexandria/search/SearchRequestTest.java
  - src/main/java/dev/alexandria/config/EmbeddingConfig.java
  - src/main/java/dev/alexandria/search/SearchProperties.java
  - src/main/resources/application.yml
  - src/main/java/dev/alexandria/mcp/McpToolService.java
  - src/main/java/dev/alexandria/search/SearchResult.java
  - src/main/java/dev/alexandria/document/DocumentChunkRepository.java
autonomous: true
requirements: [FUSE-01, FUSE-02, FUSE-03]

must_haves:
  truths:
    - "SearchService executes vector and FTS queries in parallel using virtual threads, not LangChain4j built-in RRF"
    - "Scores are fused via ConvexCombinationFusion with configurable alpha (default 0.7)"
    - "Alpha is configurable via application.properties and validated at startup to [0.0, 1.0]"
    - "Rerank candidate count is configurable via application.properties (default 30)"
    - "RRF is completely removed: no rrfK in SearchRequest, no RRF config in EmbeddingConfig, no rrfK MCP parameter"
    - "Pipeline order: parallel fetch -> CC fusion -> parent-child dedup -> rerank -> parent text substitution"
    - "Application fails to start if alpha is outside [0.0, 1.0]"
  artifacts:
    - path: "src/main/java/dev/alexandria/search/SearchProperties.java"
      provides: "@ConfigurationProperties for search.alpha and search.rerank-candidates"
      min_lines: 20
    - path: "src/main/java/dev/alexandria/search/SearchService.java"
      provides: "Dual-query parallel pipeline with CC fusion"
      min_lines: 100
    - path: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      provides: "EmbeddingStore in VECTOR mode (not HYBRID)"
      contains: "SearchMode.VECTOR"
    - path: "src/main/resources/application.yml"
      provides: "alpha and rerank-candidates config"
      contains: "alpha:"
    - path: "src/main/java/dev/alexandria/document/DocumentChunkRepository.java"
      provides: "FTS query method for standalone full-text search"
  key_links:
    - from: "src/main/java/dev/alexandria/search/SearchService.java"
      to: "src/main/java/dev/alexandria/search/ConvexCombinationFusion.java"
      via: "static method call ConvexCombinationFusion.fuse()"
      pattern: "ConvexCombinationFusion\\.fuse"
    - from: "src/main/java/dev/alexandria/search/SearchService.java"
      to: "src/main/java/dev/alexandria/search/SearchProperties.java"
      via: "constructor injection"
      pattern: "SearchProperties"
    - from: "src/main/java/dev/alexandria/search/SearchProperties.java"
      to: "src/main/resources/application.yml"
      via: "@ConfigurationProperties prefix"
      pattern: "alexandria\\.search"
    - from: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      to: "SearchMode.VECTOR"
      via: "builder configuration"
      pattern: "searchMode\\(SearchMode\\.VECTOR\\)"
---

<objective>
Wire Convex Combination fusion into the search pipeline, replace RRF with dual parallel queries, and make alpha + rerank-candidates configurable via application.properties.

Purpose: Complete the search fusion overhaul by integrating the CC engine (from Plan 01) into the live search pipeline, making the fusion strategy controllable and removing all RRF remnants.

Output: Fully functional CC-based hybrid search with configurable parameters, all RRF code removed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-search-fusion-overhaul/15-CONTEXT.md
@.planning/phases/15-search-fusion-overhaul/15-01-SUMMARY.md
@src/main/java/dev/alexandria/search/SearchService.java
@src/main/java/dev/alexandria/search/SearchRequest.java
@src/main/java/dev/alexandria/search/RerankerService.java
@src/main/java/dev/alexandria/config/EmbeddingConfig.java
@src/main/java/dev/alexandria/document/DocumentChunkRepository.java
@src/main/java/dev/alexandria/mcp/McpToolService.java
@src/main/resources/application.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SearchProperties, add FTS repository query, configure EmbeddingStore as VECTOR-only</name>
  <files>
    src/main/java/dev/alexandria/search/SearchProperties.java
    src/main/java/dev/alexandria/config/EmbeddingConfig.java
    src/main/java/dev/alexandria/document/DocumentChunkRepository.java
    src/main/resources/application.yml
    src/main/java/dev/alexandria/search/SearchRequest.java
    src/test/java/dev/alexandria/search/SearchRequestTest.java
    src/main/java/dev/alexandria/mcp/McpToolService.java
  </files>
  <action>
    **1. Create `SearchProperties` as a `@ConfigurationProperties(prefix = "alexandria.search")` class:**
    - Field `double alpha` with default 0.7. Getter returns the value.
    - Field `int rerankCandidates` with default 30. Getter returns the value.
    - Add a `@PostConstruct` (or Jakarta validation) method that validates alpha is in [0.0, 1.0] and rerankCandidates is in [10, 100]. Throw `IllegalStateException` for invalid values — this makes the application fail to start with a clear error message.
    - Use `@Validated` on the class if using Jakarta validation constraints, OR use a manual `@PostConstruct` validation method (simpler, per project convention of minimal abstractions).
    - Add `@EnableConfigurationProperties(SearchProperties.class)` in SearchProperties itself or in a config class. The simplest approach: annotate SearchProperties with `@Configuration` and `@ConfigurationProperties` together (Spring Boot relaxed binding supports this).
    - Actually, the cleanest Spring Boot 3.x pattern: use `@ConfigurationProperties(prefix = "alexandria.search")` as a record with `@ConstructorBinding` semantics (default in Spring Boot 3.x for records). But since we need validation at startup, use a class (not record) with `@PostConstruct`. Keep it simple per project conventions.

    **2. Update `application.yml`:**
    - Under `alexandria.search:`, replace `rrf-k: 60` with:
      ```yaml
      alpha: 0.7
      rerank-candidates: 30
      ```
    - Spring Boot relaxed binding maps `rerank-candidates` to `rerankCandidates`.

    **3. Update `EmbeddingConfig.embeddingStore()`:**
    - Change `SearchMode.HYBRID` to `SearchMode.VECTOR`.
    - Remove the `rrfK` parameter entirely (and the `@Value("${alexandria.search.rrf-k:60}")` injection).
    - Remove `.textSearchConfig("english")` — not needed for VECTOR mode.
    - Remove `.rrfK(rrfK)` — no more RRF.
    - Keep `.searchMode(SearchMode.VECTOR)` explicit for clarity.
    - Update the Javadoc to remove references to HYBRID mode and RRF.
    - Note: The `SearchMode` import changes from `SearchMode.HYBRID` to `SearchMode.VECTOR` but both are from same enum.

    **4. Add FTS query to `DocumentChunkRepository`:**
    - Add a native query method for standalone full-text search:
      ```java
      @Query(value = """
          SELECT embedding_id::text, text, metadata,
                 ts_rank(to_tsvector('english', coalesce(text, '')),
                         plainto_tsquery('english', :query)) AS score
          FROM document_chunks
          WHERE to_tsvector('english', coalesce(text, '')) @@ plainto_tsquery('english', :query)
          ORDER BY score DESC
          LIMIT :limit
          """, nativeQuery = true)
      List<Object[]> fullTextSearch(@Param("query") String query, @Param("limit") int limit);
      ```
    - This returns raw rows: [embedding_id, text, metadata_jsonb, score]. The SearchService will convert these to ScoredCandidate instances.
    - Use 'english' text search config to match the GIN index from V1 migration.
    - NOTE: Metadata filter support for FTS is NOT needed in this method — filters are applied post-fusion during deduplication/reranking, or we add a second overload later. Per CONTEXT.md, the pipeline is: fetch N per source -> fuse -> dedup -> rerank. Filters are applied via the EmbeddingStore's vector search (which supports them natively).
    - Actually, reconsidering: metadata filters should be applied consistently to BOTH sources to avoid fetching irrelevant candidates. Add a second overload or build the WHERE clause dynamically. The simplest approach: add a `fullTextSearchWithFilter` method that accepts an optional metadata filter condition string. But this gets complex with SQL injection risk.
    - **Simplest safe approach:** Add the FTS method WITHOUT metadata filtering. Metadata filters continue to be applied on the vector side only. The fusion + dedup + rerank pipeline will naturally filter out FTS results that don't match filters since they won't appear in the final top-N. This is acceptable because:
      - Filters narrow the candidate pool, not the final output (reranker is the arbiter)
      - FTS candidates that don't match filters get lower combined scores (no vector boost)
      - The rerank-candidates limit (30) keeps the candidate set manageable
    - If we later need FTS filtering, it can be added in a follow-up.

    **5. Remove `rrfK` from `SearchRequest`:**
    - Remove the `rrfK` field from the record.
    - Update the canonical constructor: 7 fields instead of 8 (query, maxResults, source, sectionPath, version, contentType, minScore).
    - Update convenience constructors to match.
    - Update the compact constructor (remove rrfK validation if any, keep existing validations).
    - Update Javadoc.

    **6. Update `SearchRequestTest`:**
    - Remove rrfK from all constructor calls (remove 8th argument).
    - Remove `filterFieldsDefaultToNull` assertion for rrfK.
    - Remove `allArgsConstructorSetsAllFilterFields` assertion for rrfK.
    - Update all test method constructor calls from 8-arg to 7-arg.

    **7. Update `McpToolService.searchDocs()`:**
    - Remove the `rrfK` parameter entirely from the `searchDocs` method.
    - Remove the `@ToolParam` annotation for rrfK.
    - Remove the `if (rrfK != null)` debug log.
    - Update the `SearchRequest` construction to use 7-arg constructor.
    - Update the class Javadoc if it mentions RRF.
  </action>
  <verify>
    - `./quality.sh test` passes (SearchRequestTest updated, no compilation errors)
    - Application starts without errors with the new alpha/rerank-candidates config
    - `grep -r "rrfK\|rrf-k\|rrf_k\|rrfk" src/` returns zero matches (complete RRF removal)
    - `grep -r "SearchMode.HYBRID" src/` returns zero matches
  </verify>
  <done>
    - SearchProperties bean validates alpha and rerank-candidates at startup
    - EmbeddingStore uses VECTOR mode (no hybrid, no RRF)
    - DocumentChunkRepository has fullTextSearch() native query method
    - rrfK completely removed from SearchRequest, SearchService, McpToolService, EmbeddingConfig, application.yml
    - All existing tests pass after rrfK removal
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewire SearchService for dual-query parallel fusion pipeline</name>
  <files>
    src/main/java/dev/alexandria/search/SearchService.java
    src/test/java/dev/alexandria/search/SearchServiceTest.java
  </files>
  <action>
    **1. Update SearchService constructor:**
    - Inject `SearchProperties` (constructor injection per project convention).
    - Keep existing dependencies: EmbeddingStore, EmbeddingModel, RerankerService, DocumentChunkRepository.

    **2. Replace the `search()` method pipeline:**
    - Remove the old single-query pipeline that called `embeddingStore.search()` in HYBRID mode.
    - New pipeline:

    ```
    search(request):
      1. Embed query with BGE prefix (keep existing)
      2. Build metadata filter (keep existing buildFilter())
      3. In parallel using virtual threads (StructuredTaskScope or simple ExecutorService):
         a. Vector search: embeddingStore.search() with VECTOR mode, filter, maxResults = rerankCandidates
         b. FTS search: documentChunkRepository.fullTextSearch(query, rerankCandidates)
      4. Convert both results to ScoredCandidate lists
      5. Call ConvexCombinationFusion.fuse(vectorCandidates, ftsCandidates, alpha, rerankCandidates)
      6. deduplicateByParent (existing method, works on EmbeddingMatch)
      7. resolveParentTexts (existing method)
      8. rerankerService.rerank (existing)
      9. substituteParentText (existing)
      10. Return results
    ```

    **3. Parallel execution approach:**
    - Use `java.util.concurrent.StructuredTaskScope.ShutdownOnFailure` (Java 21 preview) — NO, this is preview and may not be enabled.
    - Instead, use simple virtual thread approach:
      ```java
      var vectorFuture = Thread.ofVirtual().start(() -> vectorSearch(queryEmbedding, filter, candidates));
      var ftsFuture = Thread.ofVirtual().start(() -> ftsSearch(query, candidates));
      ```
    - Actually, simplest: use `CompletableFuture.supplyAsync()` with no executor (Spring Boot's virtual thread support will use virtual threads for the platform executor):
      ```java
      var vectorFuture = CompletableFuture.supplyAsync(() -> vectorSearch(queryEmbedding, filter));
      var ftsFuture = CompletableFuture.supplyAsync(() -> ftsSearch(request.query()));
      CompletableFuture.allOf(vectorFuture, ftsFuture).join();
      ```
    - Per Claude's discretion in CONTEXT.md: "Internal implementation of parallel query execution" — use CompletableFuture with the default executor. Virtual threads are already enabled at the Spring Boot level.

    **4. Helper methods to extract:**
    - `List<ScoredCandidate> executeVectorSearch(Embedding queryEmbedding, Filter filter, int maxResults)` — calls embeddingStore.search(), converts EmbeddingMatch to ScoredCandidate.
    - `List<ScoredCandidate> executeFullTextSearch(String query, int maxResults)` — calls documentChunkRepository.fullTextSearch(), parses Object[] rows into ScoredCandidate (needs to reconstruct TextSegment from text + metadata JSONB).
    - For FTS row parsing: `Object[] row` = [embedding_id, text, metadata_jsonb, score]. Parse metadata JSONB string into a `dev.langchain4j.data.document.Metadata` object. Use Jackson ObjectMapper or manual JSONB string parsing. Simplest: inject ObjectMapper (Spring Boot auto-configures one) or parse with `com.fasterxml.jackson.databind.ObjectMapper`.
    - Actually, avoid ObjectMapper dependency in SearchService. Instead, use PostgreSQL JSONB casting in the query to return individual metadata columns. OR: return metadata as a raw JSONB string and parse it simply.
    - **Simplest approach:** Change the FTS query in DocumentChunkRepository to also return individual metadata fields needed by ScoredCandidate (source_url, section_path, chunk_type, parent_id, content_type, version, source_name). This avoids JSONB parsing entirely:
      ```sql
      SELECT embedding_id::text,
             text,
             metadata->>'source_url' AS source_url,
             metadata->>'section_path' AS section_path,
             metadata->>'chunk_type' AS chunk_type,
             metadata->>'parent_id' AS parent_id,
             metadata->>'content_type' AS content_type,
             metadata->>'version' AS version,
             metadata->>'source_name' AS source_name,
             ts_rank(...) AS score
      FROM document_chunks
      WHERE ...
      ```
      Then build TextSegment with Metadata.from() using these individual fields.
    - Update the fullTextSearch query in DocumentChunkRepository accordingly (modify Task 1's query).

    **5. Remove old constants and fields:**
    - Remove `RERANK_CANDIDATES = 50` constant — replaced by `searchProperties.getRerankCandidates()`.
    - Keep `BGE_QUERY_PREFIX` (still needed for vector embedding).
    - Remove the `rrfK` debug logging block.

    **6. Fallback behaviour (Claude's discretion):**
    - If vector search returns empty results (all FTS): fuse with empty vector list — pure FTS scoring.
    - If FTS returns empty results (all vector): fuse with empty FTS list — pure vector scoring.
    - ConvexCombinationFusion.fuse() already handles these cases naturally (empty list means no contribution from that source).
    - Log at DEBUG level when one source returns empty.

    **7. Update SearchServiceTest:**
    - Update mock setup: SearchProperties must be mocked or stubbed.
    - Create a stubbed SearchProperties that returns alpha=0.7 and rerankCandidates=30.
    - Update all existing tests to work with the new dual-query pipeline:
      - Mock embeddingStore.search() for vector results.
      - Mock documentChunkRepository.fullTextSearch() for FTS results (this is a NEW mock interaction).
      - The fusion happens via ConvexCombinationFusion (static, no mock needed).
    - Key tests to update/add:
      - `searchExecutesBothQueriesAndFuses` — verify both embeddingStore.search and fullTextSearch called.
      - `searchUsesAlphaFromProperties` — verify fusion uses configured alpha.
      - `searchUsesRerankCandidatesFromProperties` — verify maxResults passed to both queries equals rerankCandidates.
      - `searchHandlesEmptyVectorResults` — only FTS returns results, pipeline still works.
      - `searchHandlesEmptyFtsResults` — only vector returns results, pipeline still works.
      - Keep existing filter tests (buildFilter still works the same).
      - Keep existing parent-child tests (dedup/resolve/substitute unchanged).
      - Update `searchOverFetches50CandidatesForReranking` to verify rerankCandidates (30) instead of 50.
      - Update `searchDelegatesToRerankerService` for new pipeline shape.
    - Remove test for rrfK debug logging if any.

    **8. Update SearchService Javadoc:**
    - Replace "RRF" with "Convex Combination" in class-level and method-level Javadoc.
    - Document the parallel dual-query approach.
    - Update pipeline description: embed -> parallel (vector + FTS) -> CC fusion -> dedup -> rerank -> parent text.

    **9. Update SearchResult Javadoc:**
    - Change `@param score` description from "RRF-combined score" to "Convex Combination fused score".
  </action>
  <verify>
    - `./quality.sh test` passes (all unit tests green)
    - `./quality.sh spotbugs` passes (no new findings)
    - `grep -r "RRF\|rrf\|rrfK\|HYBRID" src/main/` returns zero matches (exception: comments explaining migration)
    - SearchServiceTest covers dual-query, fusion, and fallback scenarios
  </verify>
  <done>
    - SearchService uses parallel vector + FTS queries fused via ConvexCombinationFusion
    - Alpha and rerankCandidates read from SearchProperties (configurable via application.yml)
    - All existing parent-child dedup/resolve/substitute logic preserved
    - Pipeline: embed -> parallel fetch -> CC fusion -> dedup -> rerank -> parent text substitution
    - All tests pass, including updated SearchServiceTest with dual-query mocking
    - No RRF references remain in production code
  </done>
</task>

</tasks>

<verification>
- `./quality.sh test` — all unit tests pass
- `./quality.sh spotbugs` — no new findings
- `grep -rn "rrfK\|rrf-k\|HYBRID\|RRF" src/main/` — zero matches (complete RRF removal)
- `grep "alpha" src/main/resources/application.yml` — shows `alpha: 0.7`
- `grep "rerank-candidates" src/main/resources/application.yml` — shows `rerank-candidates: 30`
- SearchService imports and calls ConvexCombinationFusion.fuse()
- SearchProperties validates alpha in [0.0, 1.0] and rerankCandidates in [10, 100] at startup
</verification>

<success_criteria>
- Hybrid search uses Convex Combination fusion instead of RRF
- Alpha is configurable via application.properties (default 0.7), validated at startup
- Rerank candidate count is configurable (default 30), supported values bounded [10, 100]
- RRF completely removed from codebase (SearchRequest, EmbeddingConfig, McpToolService, application.yml)
- Pipeline: parallel fetch -> CC fusion -> parent-child dedup -> rerank -> parent text substitution
- All existing tests pass, new tests cover dual-query fusion pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/15-search-fusion-overhaul/15-02-SUMMARY.md`
</output>
