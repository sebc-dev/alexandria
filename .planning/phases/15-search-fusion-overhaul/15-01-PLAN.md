---
phase: 15-search-fusion-overhaul
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/main/java/dev/alexandria/search/ConvexCombinationFusion.java
  - src/test/java/dev/alexandria/search/ConvexCombinationFusionTest.java
autonomous: true
requirements: [FUSE-01, FUSE-02]

must_haves:
  truths:
    - "Convex Combination fuses two scored lists into one combined list using alpha-weighted normalised scores"
    - "Min-max normalisation scales both vector and FTS scores to [0, 1] per query"
    - "Edge case: when max == min for a source, normalised score is 1.0"
    - "Alpha parameter controls vector vs FTS weight: combined = alpha * normVector + (1 - alpha) * normFTS"
    - "Results appearing in only one source get 0.0 for the missing source"
  artifacts:
    - path: "src/main/java/dev/alexandria/search/ConvexCombinationFusion.java"
      provides: "Pure computation: min-max normalisation + convex combination fusion"
      min_lines: 40
    - path: "src/test/java/dev/alexandria/search/ConvexCombinationFusionTest.java"
      provides: "TDD tests for all fusion behaviours"
      min_lines: 80
  key_links:
    - from: "src/test/java/dev/alexandria/search/ConvexCombinationFusionTest.java"
      to: "src/main/java/dev/alexandria/search/ConvexCombinationFusion.java"
      via: "direct method call"
      pattern: "ConvexCombinationFusion\\.fuse"
---

<objective>
TDD the Convex Combination fusion engine as a pure computation class.

Purpose: Replace RRF with a normalised score-weighted fusion that gives control over vector vs FTS balance. This is the core algorithm that Plan 02 will wire into SearchService.

Output: `ConvexCombinationFusion` class with full unit test coverage via RED-GREEN-REFACTOR.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-search-fusion-overhaul/15-CONTEXT.md
@src/main/java/dev/alexandria/search/SearchResult.java
@src/main/java/dev/alexandria/search/SearchService.java
</context>

<feature>
  <name>ConvexCombinationFusion</name>
  <files>
    src/main/java/dev/alexandria/search/ConvexCombinationFusion.java
    src/test/java/dev/alexandria/search/ConvexCombinationFusionTest.java
  </files>
  <behavior>
    ConvexCombinationFusion is a **pure static utility class** (final class, private constructor, no Spring bean, no state) in `dev.alexandria.search` package. It follows the same pattern as UrlNormalizer and LanguageDetector.

    **Data model:**
    Create a record `ScoredCandidate` (nested inside ConvexCombinationFusion or as package-private record in same file) with fields:
    - `String embeddingId` — unique identifier for deduplication across vector and FTS results
    - `TextSegment segment` — the LangChain4j TextSegment (text + metadata)
    - `Embedding embedding` — the embedding vector (from vector search, may be null for FTS-only hits)
    - `double score` — the raw score from the source (cosine similarity for vector, ts_rank for FTS)

    **Primary method:**
    ```java
    static List<EmbeddingMatch<TextSegment>> fuse(
        List<ScoredCandidate> vectorResults,
        List<ScoredCandidate> ftsResults,
        double alpha,
        int maxResults)
    ```

    Returns `EmbeddingMatch<TextSegment>` to stay compatible with the existing deduplicateByParent/reranker pipeline that operates on EmbeddingMatch.

    **Algorithm:**
    1. Min-max normalise vector scores to [0, 1]:
       - If max == min → all normalised scores = 1.0
       - Otherwise: `normScore = (score - min) / (max - min)`
    2. Min-max normalise FTS scores to [0, 1] (same logic)
    3. Build a map by embeddingId:
       - For each vector result: `combinedScore = alpha * normVectorScore`
       - For each FTS result: add `(1 - alpha) * normFtsScore` to existing entry or create new
       - Results only in vector: FTS contribution = 0.0
       - Results only in FTS: vector contribution = 0.0
    4. For FTS-only results missing an embedding, use a zero-vector placeholder (Embedding.from(new float[0])) since the reranker does not use embeddings.
    5. Sort by combined score descending, limit to maxResults
    6. Return as `List<EmbeddingMatch<TextSegment>>` where score = combined score

    **Cases to test (TDD order):**
    1. Empty inputs → empty result
    2. Single vector result, no FTS → score = alpha * 1.0 (normalised to max, which is 1.0 since single)
    3. Single FTS result, no vector → score = (1 - alpha) * 1.0
    4. Overlapping results (same embeddingId in both) → combined score = alpha * normV + (1 - alpha) * normF
    5. Multiple results with different scores → normalisation correct (verify specific values)
    6. max == min edge case → normalised score = 1.0 for all entries in that source
    7. Alpha = 0.0 → only FTS contributes
    8. Alpha = 1.0 → only vector contributes
    9. Alpha = 0.7 (default) → 70% vector weight
    10. maxResults limits output size
    11. Results sorted by combined score descending
    12. FTS-only result gets zero-vector placeholder embedding
  </behavior>
  <implementation>
    After tests pass:
    - ConvexCombinationFusion as final class with private constructor (static utility pattern per project convention)
    - ScoredCandidate as package-private record (not public — only used within search package)
    - @NullMarked on package (already exists for search package)
    - Ensure @Nullable on ScoredCandidate.embedding since FTS results may not have an embedding
    - Use Locale.US for any formatted output if needed
    - No Spring dependencies — pure computation
  </implementation>
</feature>

<verification>
- `./quality.sh test` passes (unit tests including new ConvexCombinationFusionTest)
- ConvexCombinationFusionTest has >= 10 test methods covering all cases listed above
- ConvexCombinationFusion has no Spring annotations, no injected dependencies
- ScoredCandidate record is package-private
</verification>

<success_criteria>
- ConvexCombinationFusion.fuse() produces correctly normalised and weighted scores
- All edge cases covered: empty, single-source, overlap, max==min, alpha extremes
- Results sorted descending by combined score and limited to maxResults
- Pure function: no I/O, no state, no Spring context needed
</success_criteria>

<output>
After completion, create `.planning/phases/15-search-fusion-overhaul/15-01-SUMMARY.md`
</output>
