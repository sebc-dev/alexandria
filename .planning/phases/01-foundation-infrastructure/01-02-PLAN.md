---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/main/resources/db/migration/V1__create_pgvector_extension.sql
  - src/main/resources/db/migration/V2__create_document_chunks.sql
  - src/main/resources/db/migration/V3__create_sources.sql
  - src/main/resources/db/migration/V4__create_ingestion_state.sql
  - src/main/java/dev/alexandria/config/EmbeddingConfig.java
  - src/main/java/dev/alexandria/config/ThreadConfig.java
  - src/integrationTest/java/dev/alexandria/EmbeddingStoreIntegrationTest.java
autonomous: true

must_haves:
  truths:
    - "Flyway runs all 4 migrations successfully against a pgvector-enabled PostgreSQL"
    - "Application generates a 384-dimension embedding vector from arbitrary text input using in-process ONNX model"
    - "Application stores an embedding with metadata in pgvector and retrieves it by cosine similarity"
    - "HNSW index on vector(384) column uses vector_cosine_ops (not halfvec_cosine_ops)"
    - "ONNX embedding runs on a dedicated platform thread pool, not virtual threads"
  artifacts:
    - path: "src/main/resources/db/migration/V1__create_pgvector_extension.sql"
      provides: "pgvector extension creation"
      contains: "CREATE EXTENSION IF NOT EXISTS vector"
    - path: "src/main/resources/db/migration/V2__create_document_chunks.sql"
      provides: "document_chunks table with vector(384) column"
      contains: "vector(384)"
    - path: "src/main/resources/db/migration/V3__create_sources.sql"
      provides: "sources table"
      contains: "CREATE TABLE sources"
    - path: "src/main/resources/db/migration/V4__create_ingestion_state.sql"
      provides: "ingestion_state table"
      contains: "CREATE TABLE ingestion_state"
    - path: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      provides: "EmbeddingModel and EmbeddingStore Spring beans"
      contains: "BgeSmallEnV15QuantizedEmbeddingModel"
    - path: "src/main/java/dev/alexandria/config/ThreadConfig.java"
      provides: "Dedicated platform thread pool for ONNX"
      contains: "newFixedThreadPool"
    - path: "src/integrationTest/java/dev/alexandria/EmbeddingStoreIntegrationTest.java"
      provides: "Integration test proving embed + store + retrieve"
      contains: "pgvector/pgvector:pg16"
  key_links:
    - from: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      to: "src/main/resources/db/migration/V2__create_document_chunks.sql"
      via: "PgVectorEmbeddingStore configured with table=document_chunks, createTable=false"
      pattern: "createTable.*false"
    - from: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      to: "src/main/resources/application.yml"
      via: "@Value datasource properties for PgVectorEmbeddingStore connection"
      pattern: "spring\\.datasource"
    - from: "src/integrationTest/java/dev/alexandria/EmbeddingStoreIntegrationTest.java"
      to: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      via: "Spring context loads EmbeddingModel and EmbeddingStore beans"
      pattern: "@Autowired.*EmbeddingModel"
---

<objective>
Create Flyway SQL migrations (4 tables: pgvector extension, document_chunks, sources, ingestion_state), LangChain4j ONNX embedding configuration beans (EmbeddingModel, EmbeddingStore), dedicated platform thread pool for ONNX, and an integration test that proves the full cycle: generate embedding from text, store in pgvector, retrieve by similarity.

Purpose: This proves the core infrastructure works end-to-end. If embedding generation, storage, and retrieval work with Testcontainers, the foundation is solid for all downstream phases (search, ingestion, MCP).

Output: Working Flyway migrations, configured embedding beans, and a passing integration test demonstrating embed-store-retrieve.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@docs/architecture.md
@build.gradle.kts
@src/main/resources/application.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Flyway SQL migrations for pgvector schema</name>
  <files>
    src/main/resources/db/migration/V1__create_pgvector_extension.sql
    src/main/resources/db/migration/V2__create_document_chunks.sql
    src/main/resources/db/migration/V3__create_sources.sql
    src/main/resources/db/migration/V4__create_ingestion_state.sql
  </files>
  <action>
Create the `src/main/resources/db/migration/` directory and 4 SQL migration files.

**V1__create_pgvector_extension.sql:**
```sql
CREATE EXTENSION IF NOT EXISTS vector;
```
This is idempotent -- Docker init.sql also creates it (belt and suspenders approach per RESEARCH.md). Handles non-Docker environments where init.sql does not run.

**V2__create_document_chunks.sql:**
User decision: `vector(384)` NOT halfvec. Full precision.

```sql
CREATE TABLE document_chunks (
    id BIGSERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    embedding vector(384),
    source_url TEXT,
    section_path TEXT,
    content_type VARCHAR(30),
    metadata JSONB DEFAULT '{}',
    tsv tsvector GENERATED ALWAYS AS (to_tsvector('english', content)) STORED,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- HNSW index for vector cosine similarity search
-- Uses vector_cosine_ops (NOT halfvec_cosine_ops) because column is vector(384)
-- Default pgvector params: m=16, ef_construction=64 (Claude's Discretion)
CREATE INDEX idx_document_chunks_embedding_hnsw
    ON document_chunks USING hnsw (embedding vector_cosine_ops);

-- GIN index for full-text search
CREATE INDEX idx_document_chunks_tsv_gin
    ON document_chunks USING gin(tsv);

-- B-tree indexes for metadata filtering
CREATE INDEX idx_document_chunks_source_url ON document_chunks (source_url);
CREATE INDEX idx_document_chunks_content_type ON document_chunks (content_type);
```

Do NOT include ANALYZE at the end -- table is empty at migration time, ANALYZE is meaningless on empty tables.

**V3__create_sources.sql:**
```sql
CREATE TABLE sources (
    id BIGSERIAL PRIMARY KEY,
    url TEXT NOT NULL UNIQUE,
    name VARCHAR(255),
    status VARCHAR(30) NOT NULL DEFAULT 'pending',
    last_crawled_at TIMESTAMPTZ,
    chunk_count INTEGER NOT NULL DEFAULT 0,
    config JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

**V4__create_ingestion_state.sql:**
```sql
CREATE TABLE ingestion_state (
    id BIGSERIAL PRIMARY KEY,
    source_id BIGINT NOT NULL REFERENCES sources(id) ON DELETE CASCADE,
    content_hash VARCHAR(64),
    last_ingested_at TIMESTAMPTZ,
    status VARCHAR(30) NOT NULL DEFAULT 'pending',
    error_message TEXT,
    chunks_processed INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_ingestion_state_source_id ON ingestion_state (source_id);
```
  </action>
  <verify>
Files exist at the correct paths. SQL syntax is valid (will be verified by the integration test in Task 3 which runs Flyway against a real pgvector instance).
  </verify>
  <done>
4 Flyway migration files exist. V1 creates pgvector extension. V2 creates document_chunks with vector(384), HNSW index (vector_cosine_ops), GIN index, and B-tree indexes. V3 creates sources. V4 creates ingestion_state with FK to sources.
  </done>
</task>

<task type="auto">
  <name>Task 2: EmbeddingConfig and ThreadConfig beans</name>
  <files>
    src/main/java/dev/alexandria/config/EmbeddingConfig.java
    src/main/java/dev/alexandria/config/ThreadConfig.java
  </files>
  <action>
Create `src/main/java/dev/alexandria/config/EmbeddingConfig.java`:

This is a `@Configuration` class providing LangChain4j beans. Since `langchain4j-spring-boot-starter` is broken on Spring Boot 4.0 (issue #4268), all beans are manually configured. Per architecture.md: injection by constructor, no @Autowired on fields, config classes create beans only -- no business logic.

```java
package dev.alexandria.config;

import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.embedding.onnx.bgesmallenv15q.BgeSmallEnV15QuantizedEmbeddingModel;
import dev.langchain4j.store.embedding.EmbeddingStore;
import dev.langchain4j.store.embedding.pgvector.PgVectorEmbeddingStore;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class EmbeddingConfig {

    @Bean
    public EmbeddingModel embeddingModel() {
        return new BgeSmallEnV15QuantizedEmbeddingModel();
    }

    @Bean
    public EmbeddingStore<TextSegment> embeddingStore(
            @Value("${spring.datasource.url}") String jdbcUrl,
            @Value("${spring.datasource.username}") String user,
            @Value("${spring.datasource.password}") String password) {

        return PgVectorEmbeddingStore.builder()
            .host(extractHost(jdbcUrl))
            .port(extractPort(jdbcUrl))
            .database(extractDatabase(jdbcUrl))
            .user(user)
            .password(password)
            .table("document_chunks")
            .dimension(384)
            .createTable(false)   // Flyway manages schema
            .useIndex(false)      // Flyway creates indexes
            .build();
    }

    // JDBC URL parsing utilities
    // Format: jdbc:postgresql://host:port/database
    private String extractHost(String jdbcUrl) {
        String withoutPrefix = jdbcUrl.substring("jdbc:postgresql://".length());
        return withoutPrefix.split(":")[0];
    }

    private int extractPort(String jdbcUrl) {
        String withoutPrefix = jdbcUrl.substring("jdbc:postgresql://".length());
        String portAndDb = withoutPrefix.split(":")[1];
        return Integer.parseInt(portAndDb.split("/")[0]);
    }

    private String extractDatabase(String jdbcUrl) {
        String withoutPrefix = jdbcUrl.substring("jdbc:postgresql://".length());
        String portAndDb = withoutPrefix.split(":")[1];
        String database = portAndDb.split("/")[1];
        // Remove query parameters if present
        if (database.contains("?")) {
            database = database.split("\\?")[0];
        }
        return database;
    }
}
```

IMPORTANT: `PgVectorEmbeddingStore` manages its own JDBC connections (separate from Spring's HikariCP DataSource). This is expected and documented in RESEARCH.md Open Question #2. Both connection pools coexist without conflict on the same database.

IMPORTANT: Set `createTable(false)` and `useIndex(false)` because Flyway manages the schema. Letting LangChain4j create its own table would bypass migration tracking.

IMPORTANT: Verify the exact class name `BgeSmallEnV15QuantizedEmbeddingModel` by checking the actual import after dependency resolution. The RESEARCH.md notes this as LOW confidence. If the class name differs, adjust the import. Check available classes in the `dev.langchain4j.model.embedding.onnx` package hierarchy.

Create `src/main/java/dev/alexandria/config/ThreadConfig.java`:

```java
package dev.alexandria.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Configuration
public class ThreadConfig {

    /**
     * Fixed-size platform thread pool for CPU-bound ONNX inference.
     * Virtual threads are enabled globally for I/O (web requests, DB operations)
     * but ONNX native JNI calls would pin virtual threads to carrier threads,
     * blocking all other virtual threads on a 4-core machine.
     *
     * @see <a href="https://openjdk.org/jeps/444">JEP 444: Virtual Threads</a>
     */
    @Bean
    public ExecutorService embeddingExecutor() {
        return Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors(),
            Thread.ofPlatform().name("onnx-", 0).factory()
        );
    }
}
```

Per user decision: virtual threads for I/O, platform threads for ONNX. Per RESEARCH.md Pitfall 6: ONNX native calls pin virtual threads.
  </action>
  <verify>
Run `./gradlew compileJava` to confirm both config classes compile.
Verify EmbeddingConfig imports resolve (especially BgeSmallEnV15QuantizedEmbeddingModel).
Verify ThreadConfig imports resolve.
  </verify>
  <done>
EmbeddingConfig.java provides EmbeddingModel (ONNX bge-small-en-v1.5-q) and EmbeddingStore (PgVectorEmbeddingStore configured for document_chunks table). ThreadConfig.java provides a platform thread ExecutorService for ONNX. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration test proving embed-store-retrieve with Testcontainers pgvector</name>
  <files>
    src/integrationTest/java/dev/alexandria/EmbeddingStoreIntegrationTest.java
  </files>
  <action>
Create an integration test in the `integrationTest` source set (configured in Phase 0) that proves the full embedding cycle works against a real pgvector instance.

This test uses Testcontainers with `pgvector/pgvector:pg16` (user decision: PG16), applies Flyway migrations, generates an embedding, stores it, and retrieves it by cosine similarity.

```java
package dev.alexandria;

import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.data.segment.TextSegment;
import dev.langchain4j.model.embedding.EmbeddingModel;
import dev.langchain4j.model.output.Response;
import dev.langchain4j.store.embedding.EmbeddingMatch;
import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
import dev.langchain4j.store.embedding.EmbeddingSearchResult;
import dev.langchain4j.store.embedding.EmbeddingStore;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest(properties = "spring.profiles.active=web")
@Testcontainers
class EmbeddingStoreIntegrationTest {

    @Container
    @ServiceConnection
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(
        DockerImageName.parse("pgvector/pgvector:pg16")
            .asCompatibleSubstituteFor("postgres")
    );

    @Autowired
    private EmbeddingModel embeddingModel;

    @Autowired
    private EmbeddingStore<TextSegment> embeddingStore;

    @Test
    void generates_384_dimension_embedding() {
        Response<Embedding> response = embeddingModel.embed("How to configure Spring Boot routing");
        Embedding embedding = response.content();

        assertThat(embedding.vector()).hasSize(384);
    }

    @Test
    void stores_and_retrieves_embedding_by_similarity() {
        // Store a document
        TextSegment segment = TextSegment.from("Spring Boot supports virtual threads since version 3.2");
        Embedding embedding = embeddingModel.embed(segment).content();
        String id = embeddingStore.add(embedding, segment);

        assertThat(id).isNotBlank();

        // Search by a semantically similar query
        Embedding queryEmbedding = embeddingModel.embed("virtual threads in Spring").content();
        EmbeddingSearchRequest request = EmbeddingSearchRequest.builder()
            .queryEmbedding(queryEmbedding)
            .maxResults(5)
            .build();

        EmbeddingSearchResult<TextSegment> result = embeddingStore.search(request);

        assertThat(result.matches()).isNotEmpty();
        assertThat(result.matches().getFirst().embedded().text())
            .contains("virtual threads");
    }

    @Test
    void flyway_migrations_create_all_tables() {
        // If we got here, Flyway already ran successfully (Spring Boot auto-runs on startup).
        // The embeddingStore operations above prove document_chunks works.
        // This test verifies the Spring context loads without migration errors,
        // which implicitly validates all 4 migration files.
        assertThat(postgres.isRunning()).isTrue();
    }
}
```

IMPORTANT NOTES:
1. The `@ServiceConnection` annotation from Spring Boot Testcontainers auto-configures `spring.datasource.url`, `spring.datasource.username`, and `spring.datasource.password` from the running container. This means both the Spring DataSource (for Flyway) and the `EmbeddingConfig` (which reads the same `@Value` properties) will connect to the Testcontainer.

2. If `@ServiceConnection` does NOT properly set the properties for `EmbeddingConfig` (because it reads via `@Value`), use `@DynamicPropertySource` instead:
```java
@DynamicPropertySource
static void configureProperties(DynamicPropertyRegistry registry) {
    registry.add("spring.datasource.url", postgres::getJdbcUrl);
    registry.add("spring.datasource.username", postgres::getUsername);
    registry.add("spring.datasource.password", postgres::getPassword);
}
```

3. If the `EmbeddingSearchRequest` builder API differs from what's shown (RESEARCH.md marks LangChain4j API as LOW confidence for exact method names), check the actual API by inspecting the LangChain4j 1.11.0 classes after dependency resolution and adjust accordingly.

4. If tests fail because the `SmokeIntegrationTest` from Phase 0 cannot load the Spring context (missing database), update it to also use `@Testcontainers` with the PostgreSQL container, or add `@Disabled("Requires Phase 1 infrastructure")` if it was a placeholder.

5. The Testcontainers PostgreSQL dependency `testcontainers-postgresql` was already added in Phase 0's integrationTest suite. The `pgvector/pgvector:pg16` Docker image will be pulled automatically on first test run.
  </action>
  <verify>
Run `./gradlew integrationTest` and confirm all 3 test methods pass:
- `generates_384_dimension_embedding` -- proves ONNX model loads and produces 384d vectors
- `stores_and_retrieves_embedding_by_similarity` -- proves pgvector store+retrieve works
- `flyway_migrations_create_all_tables` -- proves Flyway ran 4 migrations successfully

Also run `./gradlew test` to confirm unit tests still pass.
Also run `./gradlew check` to confirm the full quality pipeline (unit + integration + SpotBugs + PIT + ArchUnit) passes.
  </verify>
  <done>
Integration test passes against Testcontainers pgvector:pg16. Application generates 384-dimension embeddings from text via in-process ONNX model. Embeddings are stored in pgvector and retrieved by cosine similarity. Flyway migrations run all 4 tables successfully. Full `./gradlew check` passes.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew compileJava` -- all Java files compile (EmbeddingConfig, ThreadConfig)
2. `./gradlew test` -- unit tests pass (ArchUnit, smoke)
3. `./gradlew integrationTest` -- integration test passes against Testcontainers pgvector:pg16
4. `./gradlew check` -- full quality pipeline passes
5. Flyway migrations V1-V4 run successfully (verified by integration test)
6. Embedding generation produces 384 dimensions (verified by integration test)
7. Embedding store/retrieve works with cosine similarity (verified by integration test)
8. HNSW index uses `vector_cosine_ops` (verified by V2 migration SQL)
9. All 3 tables exist: document_chunks, sources, ingestion_state (verified by Flyway)
</verification>

<success_criteria>
- 4 Flyway migrations exist and execute successfully against pgvector:pg16
- EmbeddingModel bean generates 384-dimension vectors from arbitrary text
- EmbeddingStore bean stores and retrieves embeddings by cosine similarity in pgvector
- Dedicated platform thread pool exists for ONNX inference (not virtual threads)
- Integration test proves the full embed-store-retrieve cycle passes
- `./gradlew check` passes (all quality gates green)
- document_chunks table uses vector(384) (NOT halfvec) per user decision
- HNSW index uses vector_cosine_ops per user decision
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
