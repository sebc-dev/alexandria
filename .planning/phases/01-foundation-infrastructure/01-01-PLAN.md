---
phase: 01-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - build.gradle.kts
  - settings.gradle.kts
  - src/main/resources/application.properties
  - src/main/resources/application.yml
  - src/main/resources/application-web.yml
  - src/main/resources/application-stdio.yml
  - docker-compose.yml
  - Dockerfile
  - docker/init.sql
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "Gradle build compiles successfully with all Phase 1 dependencies (LangChain4j ONNX, pgvector, Flyway, Actuator, JPA)"
    - "Application starts with web profile and responds on /actuator/health"
    - "Application starts with stdio profile without producing console output"
    - "docker-compose.yml defines 3 services (postgres, crawl4ai, app) with health checks"
    - "Docker init.sql creates pgvector extension on fresh container"
  artifacts:
    - path: "build.gradle.kts"
      provides: "All Phase 1 dependencies declared"
      contains: "langchain4j-embeddings-bge-small-en-v15-q"
    - path: "docker-compose.yml"
      provides: "3-service Docker Compose stack"
      contains: "pgvector/pgvector:pg16"
    - path: "Dockerfile"
      provides: "Multi-stage Gradle build"
      contains: "bootJar"
    - path: "docker/init.sql"
      provides: "pgvector extension creation"
      contains: "CREATE EXTENSION IF NOT EXISTS vector"
    - path: "src/main/resources/application.yml"
      provides: "Shared Spring config with datasource and Flyway"
      contains: "flyway"
    - path: "src/main/resources/application-web.yml"
      provides: "Web profile config"
      contains: "server"
    - path: "src/main/resources/application-stdio.yml"
      provides: "Stdio profile config"
      contains: "web-application-type: none"
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "app service build context"
      pattern: "build:.*context"
    - from: "docker-compose.yml"
      to: "docker/init.sql"
      via: "volume mount to entrypoint"
      pattern: "docker-entrypoint-initdb"
    - from: "build.gradle.kts"
      to: "src/main/resources/application.yml"
      via: "Spring Boot starter dependencies enable autoconfiguration"
      pattern: "spring-boot-starter-flyway"
---

<objective>
Set up the complete infrastructure layer for Phase 1: Gradle dependencies for LangChain4j + pgvector + Flyway + Actuator, Spring Boot dual-profile configuration (web/stdio), Docker Compose with 3 services (PostgreSQL+pgvector, Crawl4AI, Java app), Dockerfile for multi-stage build, and pgvector init script.

Purpose: Every subsequent phase depends on this infrastructure. Docker Compose provides the runtime. Spring profiles enable dual-mode operation. Dependencies unlock embedding and vector storage capabilities.

Output: Buildable application with Docker Compose stack definition, dual-profile Spring Boot configuration, and all Phase 1 dependencies resolved.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@docs/architecture.md
@build.gradle.kts
@settings.gradle.kts
@src/main/resources/application.properties
@src/main/java/dev/alexandria/AlexandriaApplication.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gradle dependencies and Spring Boot profile configuration</name>
  <files>
    build.gradle.kts
    settings.gradle.kts
    src/main/resources/application.yml
    src/main/resources/application-web.yml
    src/main/resources/application-stdio.yml
  </files>
  <action>
Update `build.gradle.kts` to add all Phase 1 dependencies. Keep ALL existing plugins and configuration (JaCoCo, PIT, SpotBugs, ArchUnit, SonarCloud, JVM Test Suites). Using Gradle per research recommendation (NOT Maven, despite CONTEXT.md -- Phase 0 established Gradle with full quality infrastructure).

Add version variables at the top of dependencies block:
```
val langchain4jVersion = "1.11.0"
val langchain4jBetaVersion = "1.11.0-beta19"
```

Add to the `dependencies` block (KEEP existing dependencies):
- `implementation("org.springframework.boot:spring-boot-starter-web")` -- REST endpoints + web profile
- `implementation("org.springframework.boot:spring-boot-starter-actuator")` -- health checks for Docker
- `implementation("org.springframework.boot:spring-boot-starter-data-jpa")` -- JPA for entity management
- `implementation("org.springframework.boot:spring-boot-starter-flyway")` -- Required for Flyway on Boot 4.0 (not just flyway-core!)
- `implementation("org.flywaydb:flyway-database-postgresql")` -- PostgreSQL dialect for Flyway
- `runtimeOnly("org.postgresql:postgresql")` -- JDBC driver
- `implementation("dev.langchain4j:langchain4j:$langchain4jVersion")` -- Core RAG orchestration (NO spring-boot-starter -- broken on Boot 4.0, issue #4268)
- `implementation("dev.langchain4j:langchain4j-embeddings-bge-small-en-v15-q:$langchain4jBetaVersion")` -- In-process ONNX bge-small-en-v1.5 384d
- `implementation("dev.langchain4j:langchain4j-pgvector:$langchain4jBetaVersion")` -- pgvector embedding store

Add `spring-boot-starter-data-jpa` and `org.postgresql:postgresql` to the integrationTest dependencies as well (for Testcontainers pgvector integration tests in Plan 02).

Add Spring AI milestone repository to `settings.gradle.kts` (in `pluginManagement.repositories` or a separate `dependencyResolutionManagement` block) -- NOT needed for Phase 1 dependencies but set up for Phase 5:
```kotlin
// settings.gradle.kts addition
dependencyResolutionManagement {
    repositories {
        mavenCentral()
        maven { url = uri("https://repo.spring.io/milestone") }
    }
}
```
NOTE: If Gradle 9.3.1 conflicts with `dependencyResolutionManagement` when `repositories` is also in `build.gradle.kts`, add the milestone repo directly to `build.gradle.kts` repositories block instead. The key is that `repo.spring.io/milestone` is available for future Spring AI 2.0.0-M2 dependency.

Delete `src/main/resources/application.properties` and replace with `application.yml`.

Create `src/main/resources/application.yml` (shared config):
```yaml
spring:
  application:
    name: alexandria
  datasource:
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:alexandria}
    username: ${DB_USER:alexandria}
    password: ${DB_PASSWORD:alexandria_dev}
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  flyway:
    enabled: true
    locations: classpath:db/migration
  threads:
    virtual:
      enabled: true
```

Create `src/main/resources/application-web.yml`:
```yaml
server:
  port: 8080
management:
  endpoints:
    web:
      exposure:
        include: health,info
logging:
  level:
    dev.alexandria: DEBUG
    org.springframework: INFO
```

Create `src/main/resources/application-stdio.yml`:
```yaml
spring:
  main:
    web-application-type: none
    banner-mode: off
logging:
  pattern:
    console:
  file:
    name: ./logs/alexandria-mcp.log
  level:
    dev.alexandria: INFO
    org.springframework: WARN
```

IMPORTANT: The stdio profile MUST produce zero console output. Empty `logging.pattern.console` and `banner-mode: off` are critical for MCP protocol compatibility (per PITFALLS.md Pitfall 4).
  </action>
  <verify>
Run `./gradlew dependencies --configuration runtimeClasspath` and confirm langchain4j, flyway, actuator, JPA, and postgresql appear.
Run `./gradlew compileJava` to confirm compilation succeeds.
Run `./gradlew test` to confirm existing tests still pass.
  </verify>
  <done>
All Phase 1 dependencies resolve. Application compiles. Existing tests pass (ArchUnit, smoke test). Three YAML profile files exist. application.properties is replaced by application.yml.
  </done>
</task>

<task type="auto">
  <name>Task 2: Docker Compose stack, Dockerfile, and pgvector init</name>
  <files>
    docker-compose.yml
    Dockerfile
    docker/init.sql
    .dockerignore
  </files>
  <action>
Create `docker/init.sql`:
```sql
-- Runs as superuser during PostgreSQL container first initialization.
-- Ensures pgvector extension exists before Flyway migrations run.
CREATE EXTENSION IF NOT EXISTS vector;
```

Create `docker-compose.yml` with exactly 3 services per user decision:

**postgres** service:
- Image: `pgvector/pgvector:pg16` (user decision: PG16, NOT 17)
- Environment: POSTGRES_DB=alexandria, POSTGRES_USER=alexandria, POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-alexandria_dev}
- Ports: `"5432:5432"` (user decision: PostgreSQL exposed for debug/admin)
- Volumes: named volume `pgdata:/var/lib/postgresql/data` + `./docker/init.sql:/docker-entrypoint-initdb.d/init.sql:ro`
- Healthcheck: `pg_isready -U alexandria -d alexandria`, interval 5s, timeout 5s, retries 10, start_period 10s
- Deploy resources limits memory: 4G
- restart: unless-stopped

**crawl4ai** service:
- Image: `unclecode/crawl4ai:0.8.0`
- shm_size: 1g (required for Chromium rendering)
- Healthcheck: `curl -f http://localhost:11235/health`, interval 10s, timeout 5s, retries 5, start_period 30s
- Deploy resources limits memory: 4G
- restart: unless-stopped
- NO ports exposed (user decision: internal Docker network only)

**app** service:
- build context: `.`, dockerfile: `Dockerfile`
- Environment: SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/alexandria, SPRING_DATASOURCE_USERNAME=alexandria, SPRING_DATASOURCE_PASSWORD=${POSTGRES_PASSWORD:-alexandria_dev}, SPRING_PROFILES_ACTIVE=web, JAVA_OPTS=-Xmx2g -XX:NativeMemoryTracking=summary -Djdk.tracePinnedThreads=short
- depends_on: postgres (condition: service_healthy), crawl4ai (condition: service_healthy)
- Healthcheck: `curl -f http://localhost:8080/actuator/health`, interval 10s, timeout 5s, retries 5
- Deploy resources limits memory: 3G (2G heap + ~1G native for ONNX + metaspace)
- restart: unless-stopped
- NO ports exposed (user decision: internal Docker network only)

Named volume: `pgdata`

Total memory: 4G + 4G + 3G = 11G, well within 14 GB budget (user decision INFRA-04).

Create `Dockerfile` (multi-stage Gradle build):
```dockerfile
# Build stage
FROM eclipse-temurin:21-jdk-jammy AS build
WORKDIR /app
COPY gradlew gradle.properties settings.gradle.kts build.gradle.kts ./
COPY gradle/ gradle/
RUN ./gradlew dependencies --no-daemon || true
COPY src/ src/
COPY config/ config/
RUN ./gradlew bootJar --no-daemon -x test -x integrationTest

# Runtime stage
FROM eclipse-temurin:21-jre-jammy
WORKDIR /app
RUN addgroup --system appgroup && adduser --system --ingroup appgroup appuser

COPY --from=build /app/build/libs/*.jar app.jar
RUN mkdir -p /app/logs && chown -R appuser:appgroup /app

USER appuser
EXPOSE 8080

ENTRYPOINT ["java", \
  "-XX:NativeMemoryTracking=summary", \
  "-Djdk.tracePinnedThreads=short", \
  "-jar", "app.jar"]
```

NOTE: The Dockerfile uses `|| true` on `./gradlew dependencies` because some dependency downloads may fail in layer caching but the full build in the next step will resolve them. Also ensure `gradle.properties` is included in the COPY if it exists. If it does not exist, remove it from the COPY line.

Check if `gradle.properties` exists at project root. If not, remove it from the Dockerfile COPY line. Also verify that `config/` directory exists (for SpotBugs config). If it does, include it; if not, remove that COPY line.

Create `.dockerignore`:
```
.git
.github
.planning
.claude
build
.gradle
*.md
!README.md
```
  </action>
  <verify>
Run `docker compose config` to validate the docker-compose.yml syntax.
Verify `docker/init.sql` exists and contains CREATE EXTENSION.
Verify `Dockerfile` exists and contains multi-stage build.
Run `./gradlew bootJar -x test -x integrationTest` to confirm the JAR can be built (Docker build prerequisite).
  </verify>
  <done>
docker-compose.yml defines 3 services with correct health checks, memory limits, and dependency ordering. Dockerfile builds a multi-stage image. init.sql creates pgvector extension. .dockerignore excludes build artifacts. `./gradlew bootJar` succeeds.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew compileJava` succeeds with all new dependencies
2. `./gradlew test` passes (existing ArchUnit + smoke tests)
3. `docker compose config` validates without errors
4. `./gradlew bootJar -x test -x integrationTest` produces a JAR in build/libs/
5. Three YAML profile files exist in src/main/resources/
6. docker/init.sql contains pgvector extension creation
</verification>

<success_criteria>
- All Phase 1 dependencies (LangChain4j ONNX, pgvector, Flyway, Actuator, JPA, PostgreSQL driver) are declared and resolve
- Gradle build compiles and existing tests pass
- Docker Compose defines postgres (pgvector:pg16), crawl4ai, and app services with health checks
- Dual-profile configuration exists (web: REST+actuator, stdio: no-console-output)
- Total Docker memory allocation stays within 14 GB budget (11 GB configured)
- Dockerfile produces a valid bootJar-based image
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md`
</output>
