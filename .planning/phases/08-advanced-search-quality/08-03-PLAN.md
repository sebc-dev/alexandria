---
phase: 08-advanced-search-quality
plan: 03
type: tdd
wave: 2
depends_on:
  - 08-01
  - 08-02
files_modified:
  - src/main/java/dev/alexandria/search/SearchRequest.java
  - src/main/java/dev/alexandria/search/SearchService.java
  - src/test/java/dev/alexandria/search/SearchRequestTest.java
  - src/test/java/dev/alexandria/search/SearchServiceTest.java
autonomous: true
requirements:
  - SRCH-08
  - SRCH-09
  - SRCH-10
  - SRCH-04

must_haves:
  truths:
    - "SearchRequest accepts optional filter parameters: source, sectionPath, version, contentType, rrfK"
    - "SearchService builds composable LangChain4j Filter from SearchRequest filter params (AND logic)"
    - "SearchService over-fetches 50 candidates for reranking, then returns top maxResults after reranking"
    - "Section path filter uses prefix matching via containsString on slugified input"
    - "Content type MIXED (or null) means no content_type filter"
    - "Empty filter results return empty list (MCP layer adds explanatory messages)"
  artifacts:
    - path: "src/main/java/dev/alexandria/search/SearchRequest.java"
      provides: "Extended search request with filter fields"
      contains: "source.*sectionPath.*version.*contentType.*rrfK"
    - path: "src/main/java/dev/alexandria/search/SearchService.java"
      provides: "Filter composition + reranking pipeline"
      min_lines: 60
    - path: "src/test/java/dev/alexandria/search/SearchServiceTest.java"
      provides: "Unit tests for filter composition and reranking integration"
      min_lines: 100
  key_links:
    - from: "src/main/java/dev/alexandria/search/SearchService.java"
      to: "RerankerService"
      via: "search() calls rerankerService.rerank() after EmbeddingStore retrieval"
      pattern: "rerankerService\\.rerank"
    - from: "src/main/java/dev/alexandria/search/SearchService.java"
      to: "MetadataFilterBuilder"
      via: "buildFilter() creates composable Filter from SearchRequest fields"
      pattern: "metadataKey.*isEqualTo|containsString"
    - from: "src/main/java/dev/alexandria/search/SearchService.java"
      to: "EmbeddingSearchRequest"
      via: "filter() passed to search request, maxResults set to 50 for over-fetch"
      pattern: "maxResults.*50.*filter"
---

<objective>
Extend SearchRequest with filter parameters and wire SearchService to use composable LangChain4j metadata filters plus the RerankerService for two-stage retrieval (RRF over-fetch + cross-encoder rerank), following TDD.

Purpose: This plan connects the metadata filter infrastructure (Plan 01) with the reranking capability (Plan 02) in the search pipeline, completing the core search quality improvement for all 4 filter requirements.
Output: Extended SearchRequest, SearchService with filter composition and reranking pipeline, comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-search-quality/08-RESEARCH.md
@.planning/phases/08-advanced-search-quality/08-01-SUMMARY.md
@.planning/phases/08-advanced-search-quality/08-02-SUMMARY.md
@src/main/java/dev/alexandria/search/SearchRequest.java
@src/main/java/dev/alexandria/search/SearchService.java
@src/main/java/dev/alexandria/search/SearchResult.java
@src/main/java/dev/alexandria/search/RerankerService.java
@src/main/java/dev/alexandria/ingestion/chunking/ContentType.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SearchRequest + SearchService filter composition + reranking pipeline (TDD)</name>
  <files>
    src/main/java/dev/alexandria/search/SearchRequest.java
    src/main/java/dev/alexandria/search/SearchService.java
    src/test/java/dev/alexandria/search/SearchRequestTest.java
    src/test/java/dev/alexandria/search/SearchServiceTest.java
  </files>
  <action>
    **TDD RED -- write failing tests:**

    1. Update `SearchRequestTest.java` with new tests:
       - `filterFieldsDefaultToNull()`: verify that SearchRequest(query, 10) has null source, sectionPath, version, contentType, minScore, rrfK
       - `builderSetsAllFilterFields()`: verify a builder/constructor sets all fields including rrfK correctly
       - `queryStillValidated()`: ensure blank query still throws

    2. Write failing `SearchServiceTest.java` tests (mock EmbeddingStore, EmbeddingModel, RerankerService):
       - `searchWithNoFiltersPassesNullFilter()`: verify EmbeddingSearchRequest has null/no filter, maxResults=50 (over-fetch)
       - `searchWithSourceFilterBuildsEqualityFilter()`: verify Filter with metadataKey("source_name").isEqualTo(source) is set
       - `searchWithVersionFilterBuildsEqualityFilter()`: verify Filter with metadataKey("version").isEqualTo(version)
       - `searchWithSectionPathFilterBuildsContainsStringFilter()`: verify Filter with metadataKey("section_path").containsString(slugifiedPath)
       - `searchWithContentTypeFilterBuildsEqualityFilter()`: verify Filter with metadataKey("content_type").isEqualTo("code") when contentType="CODE"
       - `searchWithContentTypeMixedSkipsFilter()`: verify no content_type filter when contentType is "MIXED" or null
       - `searchWithMultipleFiltersCombinesWithAnd()`: verify compound filter with AND logic when multiple params set
       - `searchDelegatesToRerankerService()`: verify rerankerService.rerank() is called with correct args (query, candidates, maxResults, minScore)
       - `searchOverFetches50CandidatesForReranking()`: capture the EmbeddingSearchRequest and verify maxResults=50 regardless of requested maxResults

    **TDD GREEN -- make tests pass:**

    3. Refactor `SearchRequest` to include filter fields. Convert from simple record to a record with builder pattern or use a richer constructor:
       ```java
       public record SearchRequest(
               String query,
               int maxResults,
               String source,
               String sectionPath,
               String version,
               String contentType,
               Double minScore,
               Integer rrfK
       ) {
           private static final int DEFAULT_MAX_RESULTS = 10;
           private static final int RERANK_CANDIDATES = 50;

           public SearchRequest {
               if (query == null || query.isBlank()) {
                   throw new IllegalArgumentException("Query must not be blank");
               }
               if (maxResults < 1) {
                   throw new IllegalArgumentException("maxResults must be at least 1");
               }
           }

           // Convenience constructor for backward compatibility
           public SearchRequest(String query) {
               this(query, DEFAULT_MAX_RESULTS, null, null, null, null, null, null);
           }

           public SearchRequest(String query, int maxResults) {
               this(query, maxResults, null, null, null, null, null, null);
           }
       }
       ```

       Note: `rrfK` is accepted on SearchRequest per user decision. However, per research, rrfK is a store-level config in LangChain4j's PgVectorEmbeddingStore (set at startup, not per-request). SearchService should log a debug message if rrfK is provided and differs from the configured store-level value, noting it cannot be applied per-request. The field is carried for API completeness per the locked decision.

    4. Refactor `SearchService.search()` to implement the two-stage pipeline:
       - Inject `RerankerService` via constructor (add to existing constructor)
       - Over-fetch: set maxResults=50 on EmbeddingSearchRequest regardless of requested maxResults (50 candidates for reranking)
       - Build filter: create private `buildFilter(SearchRequest request)` method using MetadataFilterBuilder:
         - source != null -> `metadataKey("source_name").isEqualTo(source)`
         - version != null -> `metadataKey("version").isEqualTo(version)`
         - sectionPath != null -> `metadataKey("section_path").containsString(slugify(sectionPath))` -- reuse the slugification pattern from MarkdownChunker (lowercase, non-alnum to hyphens)
         - contentType != null AND ContentType.parseSearchFilter(contentType) != null -> `metadataKey("content_type").isEqualTo(parsedType.value())`
         - Combine filters with `.and()` -- use `filters.stream().reduce(Filter::and).orElse(null)`
       - If filter is non-null, set it on EmbeddingSearchRequest.builder().filter(filter)
       - After retrieval, delegate to rerankerService.rerank(query, candidates, maxResults, minScore)
       - Remove the old `toSearchResult()` private method (now handled by RerankerService)

       Add private `slugify(String input)` method (or extract from MarkdownChunker -- check if it's static and reusable). If not, create a simple version: `input.toLowerCase().replaceAll("[^a-z0-9]+", "-").replaceAll("^-|-$", "")`

    **TDD REFACTOR:** Clean up, Javadoc, verify no duplication with RerankerService.
  </action>
  <verify>
    `./quality.sh test` passes. SearchService correctly builds filters, over-fetches 50 candidates, delegates to RerankerService. All test cases verify filter composition logic.
  </verify>
  <done>
    SearchRequest carries all filter fields. SearchService implements two-stage pipeline: over-fetch 50 with metadata filters -> cross-encoder rerank -> return top maxResults. Filter composition uses AND logic with MetadataFilterBuilder. Section path slugified for prefix matching. MIXED contentType skips filter. All unit tests pass.
  </done>
</task>

</tasks>

<verification>
- `./quality.sh test` -- all unit tests pass
- `./quality.sh spotbugs` -- no new findings
- SearchRequest has source, sectionPath, version, contentType, minScore, rrfK fields
- SearchService builds LangChain4j Filter from request parameters
- SearchService over-fetches 50 candidates and delegates to RerankerService
- Section path filter uses containsString on slugified input
- MIXED/null contentType means no filter on content_type
- Multiple filters combined with AND logic
</verification>

<success_criteria>
Search pipeline is fully wired: SearchRequest accepts filter params, SearchService builds composable metadata filters and delegates to RerankerService for two-stage retrieval. All 4 filter requirements (SRCH-04, SRCH-08, SRCH-09, SRCH-10) have corresponding filter logic. Unit tests verify all filter combinations and the reranking handoff.
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-search-quality/08-03-SUMMARY.md`
</output>
