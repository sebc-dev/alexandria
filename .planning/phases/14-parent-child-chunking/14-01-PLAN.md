---
phase: 14-parent-child-chunking
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/main/java/dev/alexandria/ingestion/chunking/MarkdownChunker.java
  - src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java
  - src/main/java/dev/alexandria/ingestion/chunking/ContentType.java
  - src/main/java/dev/alexandria/ingestion/IngestionService.java
  - src/test/java/dev/alexandria/ingestion/chunking/MarkdownChunkerTest.java
  - src/test/java/dev/alexandria/ingestion/chunking/DocumentChunkDataTest.java
autonomous: true
requirements:
  - CHUNK-01

must_haves:
  truths:
    - "MarkdownChunker produces parent chunks containing full H2/H3 section text (heading + all prose + all code blocks)"
    - "MarkdownChunker produces child chunks for each individual block (paragraph, code block, table, list) within a section"
    - "Every child chunk carries a parent_id in its metadata linking it to its parent"
    - "H3 sections are sub-parents; H2 becomes direct parent only when it has no H3 children"
    - "Content before the first heading creates a root parent with its own children"
    - "H4+ headings remain inside their H3 parent as content (no third hierarchy level)"
    - "Parent chunks have chunk_type=parent in metadata; child chunks have chunk_type=child"
  artifacts:
    - path: "src/main/java/dev/alexandria/ingestion/chunking/MarkdownChunker.java"
      provides: "Parent-child chunking with two-level hierarchy"
      contains: "chunk_type"
    - path: "src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java"
      provides: "Extended record with chunkType and parentId fields"
      contains: "parentId"
    - path: "src/main/java/dev/alexandria/ingestion/chunking/ContentType.java"
      provides: "Content type enum (prose, code unchanged)"
    - path: "src/test/java/dev/alexandria/ingestion/chunking/MarkdownChunkerTest.java"
      provides: "TDD tests for parent-child chunking behavior"
      min_lines: 200
  key_links:
    - from: "MarkdownChunker.chunk()"
      to: "DocumentChunkData"
      via: "returns List<DocumentChunkData> with parent and child records"
      pattern: "new DocumentChunkData.*parentId"
    - from: "DocumentChunkData.toMetadata()"
      to: "langchain4j Metadata"
      via: "puts chunk_type and parent_id keys"
      pattern: "chunk_type.*parent_id"
---

<objective>
Refactor MarkdownChunker to produce parent-child chunk hierarchy.

Purpose: Enable "small-to-big retrieval" — small child chunks provide precision vector matching, parent chunks provide full context (code + surrounding prose reunited). This is the core data model change enabling CHUNK-01.

Output: MarkdownChunker that produces parent chunks (full H2/H3 sections) and child chunks (individual blocks) with metadata links.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-parent-child-chunking/14-CONTEXT.md
@src/main/java/dev/alexandria/ingestion/chunking/MarkdownChunker.java
@src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java
@src/main/java/dev/alexandria/ingestion/chunking/ContentType.java
@src/test/java/dev/alexandria/ingestion/chunking/MarkdownChunkerTest.java
@src/test/java/dev/alexandria/ingestion/chunking/DocumentChunkDataTest.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DocumentChunkData with parent-child metadata fields</name>
  <files>
    src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java
    src/main/java/dev/alexandria/ingestion/IngestionService.java
    src/test/java/dev/alexandria/ingestion/chunking/DocumentChunkDataTest.java
  </files>
  <action>
Add two new nullable fields to DocumentChunkData record:
- `@Nullable String chunkType` — values: "parent" or "child" (null for backward compatibility with existing callers like PreChunkedImporter)
- `@Nullable String parentId` — deterministic parent identifier for child chunks linking to their parent. Format: `{sourceUrl}#{sectionPath}` (e.g., `https://docs.example.com/guide#setup/configuration`). Null for parent chunks.

Update the `toMetadata()` method to include these in langchain4j Metadata:
- `chunk_type` key with value "parent" or "child" (only when non-null)
- `parent_id` key with the parent identifier string (only when non-null)

Update all existing constructors/call sites in MarkdownChunker that currently pass `null, null` for the last two params — these remain `null, null` initially but will be updated in Task 2.

**Update IngestionService.java:** The `enrichChunks()` method creates a new `DocumentChunkData` record via its constructor. Since the record now has two additional fields (`chunkType`, `parentId`), update the constructor call in `enrichChunks()` to pass `chunk.chunkType(), chunk.parentId()` for the two new fields — this preserves the original values through enrichment. Without this change the project will not compile.

Update DocumentChunkDataTest to verify:
- `toMetadata()` includes `chunk_type` and `parent_id` keys when set
- `toMetadata()` omits `chunk_type` and `parent_id` keys when null
- `toTextSegment()` round-trips with new metadata
- Constructor validates that parentId is null when chunkType is "parent" (parents don't have a parentId)
  </action>
  <verify>
`./quality.sh test` passes — all existing tests still green, new DocumentChunkDataTest tests pass.
  </verify>
  <done>
DocumentChunkData has chunkType and parentId fields. toMetadata() conditionally emits chunk_type and parent_id. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD refactor MarkdownChunker for parent-child hierarchy</name>
  <files>
    src/main/java/dev/alexandria/ingestion/chunking/MarkdownChunker.java
    src/test/java/dev/alexandria/ingestion/chunking/MarkdownChunkerTest.java
  </files>
  <action>
**TDD approach: Write failing tests first, then implement.**

The current MarkdownChunker produces flat chunks (one per section). Refactor to produce both parent and child chunks per section.

**Parent chunk**: Full section content — heading text + all prose + all code blocks (fenced code as raw markdown with triple backticks). Created for every H2 and H3 section. chunk_type="parent", parentId=null. sectionPath is the heading hierarchy slug.

**Child chunks**: One per individual block within a section. Each child carries chunk_type="child" and parentId="{sourceUrl}#{sectionPath}" linking to its parent. Children retain their existing contentType (PROSE or CODE) and language metadata.

**Hierarchy rules (from CONTEXT.md — locked decisions):**
- H3 = sub-parent (creates parent chunk for its content)
- H2 = top-level parent; becomes direct parent of its blocks ONLY when it has no H3 children
- If H2 contains H3 sections: each H3 is a sub-parent with its own children; content directly under H2 (before first H3) creates children of the H2 parent
- H4+ headings are treated as content within their H3 parent — no third hierarchy level
- Preamble (content before first heading) creates a "root" parent. sectionPath uses empty string or page-level info. Same parent-child treatment.
- Every H3 creates parent regardless of size

**Output ordering**: For each section, emit the parent chunk first, then all child chunks. This simplifies downstream processing.

**RED phase — Write these failing tests first:**
1. `parentChunkContainsFullSectionContent` — An H2 section with prose and code should produce a parent chunk with chunk_type="parent" containing the full section text (heading + prose + code blocks as raw markdown)
2. `childChunksCreatedForEachBlock` — An H2 section with 1 paragraph + 1 code block should produce 2 child chunks (1 prose, 1 code), each with chunk_type="child" and parentId matching sourceUrl#sectionPath
3. `h3CreatesSubParent` — An H2 with two H3 children: each H3 gets its own parent chunk, and children belong to H3 parents, not H2
4. `h2WithNoH3ChildrenIsDirectParent` — An H2 with only prose (no H3 subsections): H2 is the parent, children belong to H2
5. `h2ContentBeforeFirstH3CreatesH2Children` — An H2 with prose before its first H3: that prose becomes a child of the H2 parent, while H3 content becomes children of the H3 parent
6. `preambleCreatesRootParent` — Content before any heading creates a root parent (empty sectionPath) with children
7. `h4PlusIncludedInH3ParentContent` — H4 heading and its content are part of the H3 parent, not a separate parent
8. `parentIdFormat` — Each child's parentId is `{sourceUrl}#{sectionPath}` (e.g., `https://docs.example.com/guide#setup/configuration`)
9. `parentChunkIncludesCodeAsRawMarkdown` — Parent chunk text includes fenced code blocks verbatim (with triple backtick fences), not just the code literal
10. `singleChildSectionStillProducesParentAndChild` — Even a tiny H3 with one paragraph produces both parent and child

**GREEN phase — Implement the chunker refactor:**
Refactor the `chunk()` method and its helpers:
- In the main traversal loop, collect ALL nodes per section (prose nodes, code blocks, heading) as before
- In `emitSection()`: first build and emit the parent chunk (full section raw text), then emit individual child chunks
- The parent chunk text should include the heading, all prose, and all code blocks as they appear in the original markdown (use source spans to extract raw lines including code fences)
- For child chunks: continue the existing behavior (prose chunks from content nodes, code chunks from fenced code blocks) but add chunkType="child" and parentId

**Keep existing behavior intact:**
- Oversized prose splitting still applies to child prose chunks
- Code block language detection unchanged
- sectionPath building unchanged
- The `splitOversizedText` static method unchanged

**REFACTOR phase (if needed):**
Clean up after GREEN. Ensure extracted methods are well-named. No behavior changes.

**Update existing tests:**
The existing MarkdownChunkerTest tests assert on flat chunk structure. Update them to account for the new parent chunks in the output. For example, `splitsAtH1H2H3Boundaries` now produces more chunks (parents + children). Filter on `chunkType` in assertions where needed. Or update expected counts.
  </action>
  <verify>
`./quality.sh test` passes — all new TDD tests pass, all updated existing tests pass. No regressions in DocumentChunkDataTest, ContentTypeTest, or LanguageDetectorTest.
  </verify>
  <done>
MarkdownChunker produces parent chunks (full H2/H3 section text) and child chunks (individual blocks) with parent-child links via parentId metadata. Every locked decision from CONTEXT.md is implemented: H3 sub-parents, H2 direct parent only without H3 children, H4+ in H3 parent, preamble root parent, no size limits on parents. TDD commits: RED (failing tests), GREEN (implementation), REFACTOR (cleanup).
  </done>
</task>

</tasks>

<verification>
1. `./quality.sh test` — all unit tests pass (chunker + data tests)
2. `./quality.sh spotbugs` — no new SpotBugs findings
3. Manual code review: every CONTEXT.md locked decision has a corresponding test
4. Parent chunks contain complete section text (heading + prose + code as raw markdown)
5. Child chunks carry parentId in format `{sourceUrl}#{sectionPath}`
6. Existing callers (IngestionService, PreChunkedImporter) still compile and work (null chunkType/parentId = backward compatible)
</verification>

<success_criteria>
- MarkdownChunker.chunk() returns both parent and child DocumentChunkData records
- Every child has chunk_type="child" and a non-null parentId
- Every parent has chunk_type="parent" and null parentId
- H3 sections create sub-parents; H2 is direct parent only when no H3 children
- Content before first heading creates root parent with children
- H4+ stays in H3 parent content
- All existing unit tests pass (updated for new output structure)
- All new TDD tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-parent-child-chunking/14-01-SUMMARY.md`
</output>
