---
phase: 14-parent-child-chunking
plan: 02
type: auto
wave: 2
depends_on:
  - 14-01
files_modified:
  - src/main/java/dev/alexandria/ingestion/IngestionService.java
  - src/main/java/dev/alexandria/search/SearchService.java
  - src/main/java/dev/alexandria/search/RerankerService.java
  - src/main/java/dev/alexandria/search/SearchResult.java
  - src/main/java/dev/alexandria/document/DocumentChunkRepository.java
  - src/test/java/dev/alexandria/ingestion/IngestionServiceTest.java
  - src/test/java/dev/alexandria/search/SearchServiceTest.java
  - src/test/java/dev/alexandria/search/RerankerServiceTest.java
autonomous: true
requirements:
  - CHUNK-02

must_haves:
  truths:
    - "Parent chunks are stored in the embedding store alongside child chunks"
    - "When a child chunk matches a search query, the search service returns the parent chunk's full text as context"
    - "Multiple children matching the same parent produce a single deduplicated result (parent returned once)"
    - "Search results include the parent text, not the matched child text"
    - "Chunks without chunk_type metadata (legacy chunks from pre-phase-14 ingestion) are returned as-is without modification"
  artifacts:
    - path: "src/main/java/dev/alexandria/ingestion/IngestionService.java"
      provides: "Stores both parent and child chunks with embeddings"
      contains: "parent"
    - path: "src/main/java/dev/alexandria/search/SearchService.java"
      provides: "Parent context retrieval when child matches"
      contains: "parent_id"
    - path: "src/main/java/dev/alexandria/search/RerankerService.java"
      provides: "Reranker works with parent-child aware results"
    - path: "src/main/java/dev/alexandria/document/DocumentChunkRepository.java"
      provides: "Batch native query for parent text lookup"
      contains: "findParentTextsByKeys"
    - path: "src/test/java/dev/alexandria/search/SearchServiceTest.java"
      provides: "Tests for parent substitution and deduplication"
      min_lines: 50
  key_links:
    - from: "IngestionService.storeChunks()"
      to: "EmbeddingStore"
      via: "stores both parent and child TextSegments"
      pattern: "embeddingStore.addAll"
    - from: "SearchService.search()"
      to: "EmbeddingStore"
      via: "fetches child matches, looks up parent_id in metadata, retrieves parent text"
      pattern: "parent_id"
    - from: "SearchService"
      to: "RerankerService"
      via: "passes parent-enriched candidates to reranker"
      pattern: "rerank"
---

<objective>
Wire parent-child chunking into the ingestion and search pipeline.

Purpose: When a child chunk matches a search query, the user gets the parent's full context (code + surrounding prose reunited) instead of a narrow fragment. This is the key retrieval improvement for CHUNK-02.

Output: IngestionService stores parent+child chunks; SearchService substitutes child matches with parent content and deduplicates.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-parent-child-chunking/14-CONTEXT.md
@.planning/phases/14-parent-child-chunking/14-01-SUMMARY.md
@src/main/java/dev/alexandria/ingestion/IngestionService.java
@src/main/java/dev/alexandria/search/SearchService.java
@src/main/java/dev/alexandria/search/RerankerService.java
@src/main/java/dev/alexandria/search/SearchResult.java
@src/test/java/dev/alexandria/ingestion/IngestionServiceTest.java
@src/test/java/dev/alexandria/search/SearchServiceTest.java
@src/test/java/dev/alexandria/search/RerankerServiceTest.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ingestion pipeline stores parent and child chunks with embeddings</name>
  <files>
    src/main/java/dev/alexandria/ingestion/IngestionService.java
    src/test/java/dev/alexandria/ingestion/IngestionServiceTest.java
  </files>
  <action>
The MarkdownChunker (from Plan 01) now produces both parent and child DocumentChunkData records. Both parent and child chunks should be embedded and stored in the EmbeddingStore.

**Design decision (Claude's discretion):** Both parents AND children are embedded. Rationale:
- Parents are embedded so they can be directly matched by queries that seek broad context
- Children are embedded for precision matching (small-to-big retrieval)
- The alternative (parents as context-only, not embedded) would require a separate storage mechanism and complicate the retrieval path

**Implementation changes to IngestionService:**
- No structural changes needed to `storeChunks()` — it already embeds and stores all chunks from the list. The chunker now returns parents + children, and storeChunks processes them identically.
- Verify that the `enrichChunks()` method properly handles the new fields (chunkType and parentId should be preserved when version/sourceName enrichment is applied). Update the `enrichChunks` lambda to copy chunkType and parentId.

**Test updates for IngestionServiceTest:**
- Add test: `ingestionStoresParentAndChildChunks` — verify that when chunker returns a parent + 2 children, all 3 are embedded and stored
- Add test: `enrichChunksPreservesChunkTypeAndParentId` — verify enrichChunks does not lose parent-child metadata
- Update existing tests if they assert on chunk counts (counts will increase since parents are now included)
  </action>
  <verify>
`./quality.sh test` passes — all IngestionServiceTest tests pass including new parent-child aware tests.
  </verify>
  <done>
IngestionService stores both parent and child chunks with embeddings. enrichChunks preserves chunkType and parentId. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Search service returns parent context when child matches</name>
  <files>
    src/main/java/dev/alexandria/search/SearchService.java
    src/main/java/dev/alexandria/search/RerankerService.java
    src/main/java/dev/alexandria/search/SearchResult.java
    src/main/java/dev/alexandria/document/DocumentChunkRepository.java
    src/test/java/dev/alexandria/search/SearchServiceTest.java
    src/test/java/dev/alexandria/search/RerankerServiceTest.java
  </files>
  <action>
**Design decision (Claude's discretion):** When a child chunk matches, substitute the child's text with the parent's text in the result. The child acts as a "pointer" to the parent. The reranker scores child text against the query (since the child is what matched), but the returned result contains the parent text for context richness.

**Search pipeline changes:**

1. **After hybrid search retrieves candidates** from EmbeddingStore, identify child matches by checking `chunk_type` metadata:
   - If `chunk_type == "child"`, extract `parent_id` from metadata
   - Look up the parent's text by querying the EmbeddingStore with a metadata filter: `metadataKey("chunk_type").isEqualTo("parent")` AND the parent's `source_url` and `section_path` matching the child's `parent_id` components (parse sourceUrl and sectionPath from the parentId format `{sourceUrl}#{sectionPath}`)
   - Alternative simpler approach (preferred): Use a native query on DocumentChunkRepository to fetch parent text by matching metadata `chunk_type=parent` AND `source_url` AND `section_path`. This avoids embedding search overhead for context lookups.

2. **Deduplication**: When multiple children from the same parent match:
   - Group child matches by parent_id
   - Keep the highest-scoring child per parent group (for reranking)
   - After reranking, deduplicate: one parent in results per unique parent_id
   - The score used is the best child's reranking score

3. **SearchResult changes** — no structural changes needed to the SearchResult record. The `text` field will contain parent text (or child text when chunk_type is "parent" or null for backward compatibility). Consider adding a field to indicate the content came from parent resolution, but this is optional.

4. **Implementation approach for parent text lookup:**
   Add a method to SearchService: `resolveParentText(List<EmbeddingMatch<TextSegment>> matches)` that:
   - Collects all unique parent_ids from child matches
   - Does a single batch query to DocumentChunkRepository for parent text: native query `SELECT text FROM document_chunks WHERE metadata->>'chunk_type' = 'parent' AND metadata->>'source_url' = ? AND metadata->>'section_path' = ?`
   - Returns a Map<String, String> of parentId -> parent text
   - For matches that are already parents (chunk_type="parent") or have no chunk_type (legacy), keep their text as-is

5. **Add DocumentChunkRepository method**: `findParentTextsByKeys(List<String[]> sourceUrlAndSectionPath)` — batch native query to fetch parent texts.

6. **Update RerankerService**: The reranker should score the CHILD text against the query (child matched, child is relevant), but after scoring, substitute parent text in the SearchResult. So: rerank first on child text, then substitute parent text in the returned SearchResult.

   Concretely in `RerankerService.rerank()`: the method receives candidates with original (child) text for scoring. After scoring, the caller (SearchService) does parent text substitution. No changes needed in RerankerService itself — the substitution happens in SearchService after reranking.

7. **Updated SearchService.search() flow:**
   a. Embed query, build filter, fetch RERANK_CANDIDATES from EmbeddingStore
   b. Deduplicate by parent_id: group child matches, keep best-scoring per parent
   c. Pass deduplicated candidates to rerankerService.rerank() (child text for scoring)
   d. After reranking: resolve parent text for child results
   e. Build final SearchResult list with parent text substituted

**Tests:**
- `searchSubstitutesParentTextForChildMatch` — mock EmbeddingStore returns a child match with parent_id; mock repo returns parent text; verify SearchResult.text is parent text
- `searchDeduplicatesMultipleChildrenOfSameParent` — 3 children of same parent in candidates; only 1 result returned
- `searchPassesThroughParentMatchDirectly` — a parent chunk matches directly; returned as-is
- `searchHandlesLegacyChunksWithoutChunkType` — chunks without chunk_type metadata are returned as-is (backward compatibility)
- `searchKeepsHighestScoringChildPerParent` — 2 children of same parent with different scores; highest score child is kept for reranking
  </action>
  <verify>
`./quality.sh test` passes — all SearchServiceTest and RerankerServiceTest tests pass. `./quality.sh spotbugs` clean.
  </verify>
  <done>
Search returns parent chunk text when child chunk matches. Multiple children of same parent deduplicated to single result. Reranker scores child text; result contains parent text. Legacy chunks without chunk_type handled. All unit tests pass.
  </done>
</task>

</tasks>

<verification>
1. `./quality.sh test` — all unit tests pass
2. `./quality.sh spotbugs` — no new findings
3. Parent text substitution: child match -> parent text in SearchResult
4. Deduplication: same parent_id -> single result
5. Backward compatibility: chunks without chunk_type work unchanged
6. Reranking: scores computed on child text (precision), results contain parent text (context)
</verification>

<success_criteria>
- When a child chunk matches, SearchResult.text contains the parent's full section content
- Multiple children of same parent produce exactly one search result
- Parent chunks that match directly are returned as-is
- Legacy chunks without parent-child metadata continue to work
- Reranker scores child text for relevance, result carries parent text for context
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-parent-child-chunking/14-02-SUMMARY.md`
</output>
