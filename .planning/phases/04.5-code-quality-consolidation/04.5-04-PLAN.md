---
phase: 04.5-code-quality-consolidation
plan: 04
type: execute
wave: 2
depends_on: ["04.5-01"]
files_modified:
  - src/test/java/dev/alexandria/ingestion/IngestionServiceTest.java
  - src/test/java/dev/alexandria/ingestion/prechunked/PreChunkedImporterTest.java
requirements: []
autonomous: true

must_haves:
  truths:
    - "IngestionService has unit tests covering chunking, embedding, and storage pipeline"
    - "PreChunkedImporter has unit tests covering validation, replacement semantics, and error handling"
    - "All new tests run without Spring context (pure unit tests with mocks)"
  artifacts:
    - path: "src/test/java/dev/alexandria/ingestion/IngestionServiceTest.java"
      provides: "Unit tests for IngestionService pipeline with mocked chunker, embeddingModel, embeddingStore"
    - path: "src/test/java/dev/alexandria/ingestion/prechunked/PreChunkedImporterTest.java"
      provides: "Unit tests for PreChunkedImporter with mocked validator, embeddingModel, embeddingStore"
  key_links:
    - from: "IngestionServiceTest"
      to: "IngestionService"
      via: "mocks MarkdownChunker, EmbeddingModel, EmbeddingStore"
      pattern: "@Mock.*EmbeddingModel"
    - from: "PreChunkedImporterTest"
      to: "PreChunkedImporter"
      via: "mocks Validator, EmbeddingModel, EmbeddingStore"
      pattern: "@Mock.*Validator"
---

<objective>
Add unit tests for IngestionService and PreChunkedImporter -- the two service classes with zero unit test coverage.

Purpose: These services orchestrate the entire ingestion pipeline. They currently rely solely on integration tests (which require Docker/Testcontainers). Unit tests verify the orchestration logic (chunking -> embedding -> storage) without infrastructure.
Output: 2 new test classes with comprehensive behavior coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.5-code-quality-consolidation/04.5-RESEARCH.md
@src/main/java/dev/alexandria/ingestion/IngestionService.java
@src/main/java/dev/alexandria/ingestion/prechunked/PreChunkedImporter.java
@src/main/java/dev/alexandria/ingestion/prechunked/PreChunkedRequest.java
@src/main/java/dev/alexandria/ingestion/prechunked/PreChunkedChunk.java
@src/main/java/dev/alexandria/ingestion/chunking/MarkdownChunker.java
@src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unit tests for IngestionService</name>
  <files>
    src/test/java/dev/alexandria/ingestion/IngestionServiceTest.java
  </files>
  <action>
    Create IngestionServiceTest with mocked dependencies: MarkdownChunker, EmbeddingModel, EmbeddingStore (and any other collaborators IngestionService depends on -- read the constructor).

    Use @ExtendWith(MockitoExtension.class), @Mock, @InjectMocks.

    **Test cases (camelCase naming, AAA structure):**

    **Happy path:**
    - `ingestCrawlResultChunksAndStoresEmbeddings` -- Provide a CrawlResult with markdown, stub MarkdownChunker to return DocumentChunkData list, stub EmbeddingModel.embedAll() to return embeddings, verify EmbeddingStore.addAll() called with correct TextSegments and embeddings.

    **Pipeline orchestration:**
    - `ingestPassesSourceUrlToChunker` -- Verify MarkdownChunker.chunk() receives the correct source URL and markdown content from CrawlResult.
    - `ingestCreatesTextSegmentsWithCorrectMetadata` -- Verify TextSegment metadata includes source_url, section_path, content_type, language, last_updated from DocumentChunkData fields.

    **Edge cases:**
    - `ingestEmptyMarkdownProducesNoChunks` -- CrawlResult with empty markdown, MarkdownChunker returns empty list, verify EmbeddingStore.addAll() not called (or called with empty list).
    - `ingestFailedCrawlResultIsSkipped` -- CrawlResult with success=false, verify no processing occurs.

    **Error handling (if applicable):**
    - If IngestionService has any error handling logic, test it.

    Read IngestionService.java to understand the exact pipeline steps and dependencies before writing tests. Use ArgumentCaptor to verify complex arguments passed to mocks.
  </action>
  <verify>
    `./quality.sh test` passes all tests including new IngestionServiceTest. Tests run without Spring context (no @SpringBootTest).
  </verify>
  <done>IngestionServiceTest covers pipeline orchestration: chunking, metadata mapping, embedding, storage. All tests use camelCase naming and AAA structure. Tests run without Docker.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for PreChunkedImporter</name>
  <files>
    src/test/java/dev/alexandria/ingestion/prechunked/PreChunkedImporterTest.java
  </files>
  <action>
    Create PreChunkedImporterTest with mocked dependencies: Validator, EmbeddingModel, EmbeddingStore (and any other collaborators -- read the constructor).

    Use @ExtendWith(MockitoExtension.class), @Mock, @InjectMocks.

    **Test cases (camelCase naming, AAA structure):**

    **Happy path:**
    - `importValidChunksCreatesTextSegmentsAndStoresEmbeddings` -- Provide valid PreChunkedRequest with chunks, stub Validator to return no violations, stub EmbeddingModel.embedAll(), verify EmbeddingStore operations.

    **Validation:**
    - `importInvalidRequestThrowsException` -- Provide PreChunkedRequest that fails validation, stub Validator to return violations, verify exception thrown before any storage.

    **Replacement semantics:**
    - `importRemovesExistingChunksBeforeAddingNew` -- Verify EmbeddingStore.removeAll() called with source_url filter BEFORE addAll(). This tests the all-or-nothing replacement behavior.

    **Edge cases:**
    - `importEmptyChunksListIsHandled` -- PreChunkedRequest with empty chunks list.

    **Metadata mapping:**
    - `importMapsChunkFieldsToTextSegmentMetadata` -- Verify PreChunkedChunk fields (text, sourceUrl, sectionPath, contentType, language) map correctly to TextSegment metadata keys.

    Read PreChunkedImporter.java to understand the exact flow: validate -> removeAll(filter) -> embedAll -> addAll. Use ArgumentCaptor for complex verifications.
  </action>
  <verify>
    `./quality.sh test` passes all tests including new PreChunkedImporterTest. Tests run without Spring context.
  </verify>
  <done>PreChunkedImporterTest covers validation, replacement semantics, metadata mapping, and edge cases. All tests use camelCase naming and AAA structure. Tests run without Docker.</done>
</task>

</tasks>

<verification>
- `./quality.sh test` passes all unit tests (old + new)
- 2 new test files exist: IngestionServiceTest, PreChunkedImporterTest
- All new tests use camelCase naming
- Tests do NOT require @SpringBootTest or Docker containers
- Coverage for ingestion and ingestion/prechunked packages increases (run `./quality.sh coverage` to verify)
</verification>

<success_criteria>
IngestionService and PreChunkedImporter both have unit test coverage. Pipeline orchestration logic is verified independently from infrastructure.
</success_criteria>

<output>
After completion, create `.planning/phases/04.5-code-quality-consolidation/04.5-04-SUMMARY.md`
</output>
