# Phase 4.5: Code Quality & Test Consolidation - Research

**Researched:** 2026-02-19
**Domain:** Codebase quality, test consolidation, Javadoc, refactoring
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Strategie de couverture
- Couverture utilisee comme **outil d'analyse**, pas comme gate bloquant -- les rapports identifient les trous, on juge si chaque test manquant vaut la peine d'etre ecrit
- Analyser **tous les packages uniformement** : config, crawl, ingestion/chunking, ingestion/prechunked, search, document, source -- radiographie complete
- PIT (mutation testing) lance sur **tout le codebase** pour identifier les tests faibles et les mutations survivantes
- Ajouter des tests unitaires ET des tests d'integration **selon le besoin** -- si un service n'a aucun IT, en ajouter ; sinon combler les unitaires

#### Scope du refactoring
- Refactoring **pragmatique selon lisibilite** : decouper si la methode fait plusieurs choses distinctes, tolerer si le flux est lineaire et lisible meme au-dela de 30 lignes
- Methodes **publiques et privees** sont toutes candidates au refactoring
- **Pas de restructuration** de patterns, packages ou nommage de classes -- on ne touche qu'aux methodes longues
- **Regles Javadoc completes** a appliquer pendant le refactoring :
  - TOUJOURS documenter : classes/interfaces (role, responsabilite, contexte architectural), methodes publiques d'API (intention, contrat, cas limites), @param avec semantique metier, @return avec ce que represente la valeur, @throws avec condition de declenchement, contraintes metier non deductibles du code, records/DTOs pour les champs non evidents
  - JAMAIS documenter : getters/setters triviaux, methodes dont la Javadoc repete le nom, Javadoc generee sans enrichissement, details d'implementation qui changent souvent
  - FORMAT : premiere phrase = resume autonome, utiliser @see et {@link}, annoter @Nullable/@NonNull, preferer les exemples concrets, documenter constantes et valeurs par defaut avec justification

#### Consolidation des tests
- **Hybride** pour les fixtures : builders legers pour les entites JPA (DocumentChunk, Source), records construits inline
- **Harmoniser tous les noms de tests** existants vers la convention **camelCase descriptif** (ex: `deliveryWithPastDateIsInvalid`)
- **Structure plate** pour les classes de test -- pas de @Nested, tous les tests au meme niveau

#### Limites du cleanup
- **Tout est fair game** : aucune zone protegee, Claude peut nettoyer partout dans src/
- Dead code + imports inutilises + **dependances Gradle non utilisees** a auditer et supprimer
- TODOs existants : **resoudre ou supprimer** -- chaque TODO est traite, soit implemente soit supprime si plus pertinent
- **Revue complete de la config Spring** : auditer application.yml, verifier que chaque propriete est referencee, reorganiser si necessaire

### Claude's Discretion
- Ordre de traitement des packages (quel package analyser en premier)
- Seuils de couverture par package -- pas de minimum impose, jugement au cas par cas
- Choix des mutations PIT a traiter en priorite
- Decisions de refactoring methode par methode (decouper ou non selon complexite cognitive)

### Deferred Ideas (OUT OF SCOPE)
None -- discussion stayed within phase scope
</user_constraints>

## Summary

The Alexandria codebase is compact (33 Java source files, ~1800 lines main, ~1700 lines tests) and well-structured. The research reveals a codebase that is already reasonably well maintained but has clear, addressable gaps in test coverage, Javadoc completeness, test naming consistency, and integration test duplication.

**Current quality baseline from existing reports:**
- **JaCoCo coverage:** 41% line coverage (236 covered / 577 total lines) -- driven by unit tests only. Several packages have zero unit test coverage (config, crawl/CrawlService, crawl/PageDiscoveryService, crawl/SitemapParser, crawl/Crawl4AiClient, source, document, ingestion/IngestionState).
- **PIT mutation testing:** 51% mutation score (58 killed / 113 total). 20 surviving mutations, all concentrated in `MarkdownChunker` (19) and `LanguageDetector` (1).
- **SpotBugs:** 23 findings across 11 classes -- 14x EI_EXPOSE_REP2 (mutable input stored without copy), 9x EI_EXPOSE_REP (mutable internal state exposed), 3x CT_CONSTRUCTOR_THROW (constructor throws in non-final class).
- **TODOs/FIXMEs:** Zero found in source code.
- **Test naming:** Mixed conventions -- MarkdownChunkerTest/LanguageDetectorTest use camelCase, UrlNormalizerTest/SearchRequestTest/ITs use snake_case. Harmonization needed per user decision.
- **Javadoc:** Good on services and domain DTOs. Missing on JPA entities (Source, DocumentChunk, IngestionState), repositories, config classes (EmbeddingConfig, Crawl4AiConfig, GlobalExceptionHandler), and Crawl4AI DTOs.

**Primary recommendation:** Process the codebase package-by-package, starting with the most complex/critical packages (ingestion/chunking, search, crawl), running coverage + PIT analysis, adding tests where gaps exist, refactoring long methods, adding Javadoc, and harmonizing test names. End with cross-cutting cleanup (dead code, Spring config audit, Gradle dependency audit).

## Standard Stack

No new libraries are needed for this phase. All tools are already in the build:

### Core (Already Present)
| Tool | Version | Purpose | Status |
|------|---------|---------|--------|
| JaCoCo | 0.8.14 | Code coverage | Configured in build.gradle.kts |
| PIT | 1.21.0 (engine) | Mutation testing | Configured, targets `dev.alexandria.*` |
| SpotBugs | 6.4.8 (plugin) | Bug detection | Configured with HTML+XML reports |
| ArchUnit | 1.4.1 | Architecture rules | 4 rules enforced |
| JUnit 5 | (via Spring Boot 3.5.7) | Test framework | Used in all test suites |
| AssertJ | (via Spring Boot 3.5.7) | Fluent assertions | Used in all tests |
| Mockito | (via Spring Boot 3.5.7) | Test doubles | Used in SearchServiceTest |
| Testcontainers | 1.21.1 | Integration test infra | pgvector + crawl4ai containers |

### Supporting (Already Present)
| Tool | Version | Purpose | When Used |
|------|---------|---------|-----------|
| quality.sh | - | Quality gate runner script | `./quality.sh coverage`, `./quality.sh mutation` |
| Gradle | (wrapper) | Build tool | `./gradlew test`, `./gradlew pitest` |

### Not Needed
No new dependencies required. This phase uses exclusively existing tooling.

## Architecture Patterns

### Codebase Structure (Current)
```
src/main/java/dev/alexandria/    (33 files, ~1800 LOC)
├── config/          2 files  EmbeddingConfig, GlobalExceptionHandler
├── crawl/           10 files CrawlService, Crawl4AiClient, SitemapParser, PageDiscoveryService, DTOs
├── ingestion/       3 files  IngestionService, IngestionState, IngestionStateRepository
│   ├── chunking/    4 files  MarkdownChunker, LanguageDetector, DocumentChunkData, ContentType
│   └── prechunked/  3 files  PreChunkedImporter, PreChunkedRequest, PreChunkedChunk
├── search/          3 files  SearchService, SearchRequest, SearchResult
├── document/        2 files  DocumentChunk, DocumentChunkRepository
├── source/          3 files  Source, SourceRepository, SourceStatus
└── AlexandriaApplication.java
```

### Test Structure (Current)
```
src/test/           (6 files, ~800 LOC)
├── ingestion/chunking/  MarkdownChunkerTest (19 tests), LanguageDetectorTest (15 tests)
├── crawl/               UrlNormalizerTest (9 tests)
├── search/              SearchServiceTest (4 tests), SearchRequestTest (5 tests)
└── architecture/        ArchitectureTest (4 rules)

src/integrationTest/ (10 files, ~900 LOC)
├── BaseIntegrationTest (shared pgvector container)
├── SmokeIntegrationTest, JpaSchemaDriftIT, EmbeddingStoreIT
├── ingestion/           IngestionServiceIT (4 tests)
│   └── prechunked/      PreChunkedImporterIT (5 tests), PreChunkedImporterRollbackIT (1 test)
├── crawl/               Crawl4AiClientIT (3 tests), CrawlServiceIT (3 tests)
└── search/              HybridSearchIT (6 tests)
```

### Pattern: Test Fixture Builders for JPA Entities

User decided on "lightweight builders for JPA entities (DocumentChunk, Source), records constructed inline." This applies to:

- **Source entity:** Has mutable fields (status, lastCrawledAt, chunkCount), requires builder for test convenience
- **DocumentChunk entity:** Has constructor + JPA no-arg, could benefit from builder
- **IngestionState entity:** Has constructor, relatively simple
- **Records (CrawlResult, SearchRequest, etc.):** Constructed inline with `new Record(...)`, no builder needed

Builder pattern for JPA entities (example):
```java
public class SourceBuilder {
    private String url = "https://docs.example.com";
    private String name = "Example Docs";
    private SourceStatus status = SourceStatus.PENDING;
    private int chunkCount = 0;
    // ... fluent setters returning this ...
    public Source build() { ... }
}
```

### Pattern: Test Name Harmonization

Current state: Mixed naming conventions across the codebase.

**snake_case tests (need renaming to camelCase):**
- UrlNormalizerTest: `normalize_removes_fragment`, `isSameSite_matches_same_host`, etc. (9 tests)
- SearchRequestTest: `default_maxResults_is_10`, `null_query_throws_IllegalArgumentException`, etc. (5 tests)
- SearchServiceTest: `search_returns_result_with_correct_fields_and_passes_both_query_and_embedding`, etc. (4 tests)
- All integration tests: `ingest_crawl_result_produces_searchable_chunks`, `import_valid_chunks_makes_them_searchable`, etc. (~27 tests)

**Already camelCase (no change needed):**
- MarkdownChunkerTest: `splitsAtH1H2H3Boundaries`, `extractsCodeBlockAsSeparateChunk`, etc. (19 tests)
- LanguageDetectorTest: `detectsJavaFromPublicClassAndStaticVoidMain`, etc. (15 tests)

**Total renames needed:** ~45 test methods across ~10 files.

### Anti-Patterns to Avoid
- **Over-testing trivia:** Don't add unit tests for JPA entity getters/setters, record accessors, or Spring Boot @Configuration wiring (covered by integration tests).
- **Coverage as a goal:** Don't write assertion-free tests to inflate coverage. Each test must verify a specific behavior.
- **Fixture over-engineering:** Builders only for JPA entities with mutable state. Records are already easy to construct inline.

## Current Coverage Analysis (Package-by-Package)

### Package: ingestion/chunking (MarkdownChunker, LanguageDetector, ContentType, DocumentChunkData)
- **Unit test coverage:** HIGH. 19 tests for MarkdownChunker, 15 for LanguageDetector.
- **PIT mutations:** 19 surviving mutations in MarkdownChunker (mostly in `appendNodeText`, `emitChunks`, `splitOversizedText`, `splitBySentences`), 1 in LanguageDetector.
- **Javadoc:** Complete on MarkdownChunker, LanguageDetector, DocumentChunkData, ContentType.
- **Action needed:** Kill surviving mutations with targeted boundary tests. No Javadoc needed.

### Package: search (SearchService, SearchRequest, SearchResult)
- **Unit test coverage:** MEDIUM. 4 tests for SearchService (mocked), 5 for SearchRequest validation.
- **Integration tests:** 6 tests in HybridSearchIT.
- **Javadoc:** Complete on all classes.
- **Action needed:** Test naming harmonization (snake_case -> camelCase). Minor: consider edge cases.

### Package: crawl (CrawlService, Crawl4AiClient, SitemapParser, PageDiscoveryService, UrlNormalizer, DTOs)
- **Unit test coverage:** LOW. Only UrlNormalizerTest (9 tests). No unit tests for CrawlService, Crawl4AiClient, PageDiscoveryService, SitemapParser.
- **Integration tests:** 3 for Crawl4AiClientIT, 3 for CrawlServiceIT.
- **Javadoc:** Good on CrawlService, PageDiscoveryService, SitemapParser, UrlNormalizer. Missing on Crawl4AiClient (class-level), Crawl4AiConfig, and all Crawl4AI DTOs (CrawlResult, Crawl4AiResponse, Crawl4AiPageResult, Crawl4AiRequest, Crawl4AiLink, Crawl4AiMarkdown).
- **Action needed:** Add unit tests for CrawlService (mock Crawl4AiClient + PageDiscoveryService), Crawl4AiClient (mock RestClient), PageDiscoveryService (mock SitemapParser). SitemapParser is tricky (RestClient.Builder) -- may need IT. Add Javadoc to Crawl4AiClient, Crawl4AiConfig, DTOs. Test name harmonization.

### Package: ingestion (IngestionService, IngestionState, IngestionStateRepository)
- **Unit test coverage:** ZERO. No unit tests for IngestionService.
- **Integration tests:** 4 tests in IngestionServiceIT.
- **Javadoc:** Complete on IngestionService. Missing on IngestionState, IngestionStateRepository.
- **Action needed:** Add unit test for IngestionService (mock chunker, embeddingModel, embeddingStore). Add Javadoc to IngestionState and IngestionStateRepository.

### Package: ingestion/prechunked (PreChunkedImporter, PreChunkedRequest, PreChunkedChunk)
- **Unit test coverage:** ZERO. No unit tests.
- **Integration tests:** 5 in PreChunkedImporterIT, 1 in PreChunkedImporterRollbackIT.
- **Javadoc:** Complete on all classes.
- **Action needed:** Add unit test for PreChunkedImporter (mock validator, embeddingModel, embeddingStore). Test naming harmonization on ITs.

### Package: config (EmbeddingConfig, GlobalExceptionHandler)
- **Unit test coverage:** ZERO.
- **Integration tests:** Covered indirectly by SmokeIntegrationTest.
- **Javadoc:** Missing on both classes.
- **Action needed:** Add Javadoc. No unit tests needed (trivial @Configuration, covered by ITs).

### Package: document (DocumentChunk, DocumentChunkRepository)
- **Unit test coverage:** ZERO.
- **Integration tests:** Covered by JpaSchemaDriftIT.
- **Javadoc:** Missing on both.
- **Action needed:** Add Javadoc. No unit tests needed (JPA entity with no business logic).

### Package: source (Source, SourceRepository, SourceStatus)
- **Unit test coverage:** ZERO.
- **Integration tests:** Covered by JpaSchemaDriftIT.
- **Javadoc:** Missing on all three.
- **Action needed:** Add Javadoc. No unit tests needed (JPA entity with no business logic).

## SpotBugs Analysis

### 23 findings breakdown:

**EI_EXPOSE_REP2 (14 instances) -- Mutable input stored without defensive copy:**
Found in records receiving `List` parameters: CrawlResult, Crawl4AiRequest, Crawl4AiResponse, Crawl4AiPageResult, PreChunkedRequest, and in IngestionService/SearchService/PreChunkedImporter constructors storing mutable objects.

**Resolution strategy:**
- For records receiving `List<>`: Use `List.copyOf()` in compact constructors for defensive copies. This is a valid SpotBugs finding for API DTOs.
- For service constructors storing injected Spring beans: These are false positives (Spring beans are singletons). Suppress or exclude in SpotBugs filter.

**EI_EXPOSE_REP (9 instances) -- Mutable internal state returned:**
Found in methods returning `List` from records and entities.

**Resolution strategy:**
- Record component accessors already return their stored reference. If we use `List.copyOf()` on input, the stored list is immutable and the accessor returns an immutable list -- both findings resolve together.
- JPA entity getters returning `Instant`: Not actually mutable (Instant is immutable in Java). Suppress in SpotBugs filter.

**CT_CONSTRUCTOR_THROW (3 instances) -- Constructor throws in non-final class:**
Found in JPA entities (Source, DocumentChunk, IngestionState) due to JPA lifecycle callbacks.

**Resolution strategy:** Suppress in SpotBugs filter. JPA entities must be non-final (for Hibernate proxies) and the @PrePersist callbacks are by design.

## Integration Test Consolidation

### Duplicate Patterns Found

**cleanStore() @BeforeEach:** Duplicated in 4 integration test classes (EmbeddingStoreIT, IngestionServiceIT, PreChunkedImporterIT, PreChunkedImporterRollbackIT). Each has:
```java
@Autowired EmbeddingStore<TextSegment> embeddingStore;
@BeforeEach void cleanStore() { embeddingStore.removeAll(); }
```

**Resolution:** Can be moved to BaseIntegrationTest. However, only 4 out of 9 IT classes need it (the ones using EmbeddingStore). Two options:
1. Add to BaseIntegrationTest (simpler, but cleans store unnecessarily for JpaSchemaDriftIT, SmokeIntegrationTest, Crawl4AiClientIT, CrawlServiceIT)
2. Create a separate `BaseEmbeddingIntegrationTest extends BaseIntegrationTest` (cleaner separation)

**Recommended:** Option 1 (add to BaseIntegrationTest). The `removeAll()` call is idempotent and cheap. The simplicity outweighs the minor inefficiency.

### Crawl4AI Container Duplication
Both `Crawl4AiClientIT` and `CrawlServiceIT` independently create a Crawl4AI testcontainer. This means two separate containers if both tests run. Consider extracting to a shared container pattern (similar to BaseIntegrationTest for postgres).

## Method Length Analysis

Analyzing all methods with body > 30 lines:

### MarkdownChunker.chunk() -- ~33 lines (lines 63-112)
Linear flow: parse -> iterate nodes -> flush final section. Multiple concerns (heading tracking, content accumulation, code block collection, flushing). **Candidate for refactoring** -- can extract the while-loop body into a `processNode()` method.

### MarkdownChunker.emitChunks() -- ~40 lines (lines 114-154)
Two distinct responsibilities: emit prose chunk (with oversized splitting) and emit code chunks. **Candidate for refactoring** -- can split into `emitProseChunk()` and `emitCodeChunks()`.

### MarkdownChunker.splitOversizedText() -- ~38 lines (lines 234-271)
Single responsibility but complex paragraph-boundary splitting. Linear flow with nested conditionals. **Borderline** -- could be left as-is since it's a static utility with clear logic, but the nested if/else inside the for loop could be simplified.

### CrawlService.crawlSite() -- ~50 lines (lines 41-91)
BFS crawl loop with URL normalization, dedup, link discovery. **Candidate for refactoring** -- the while-loop body (lines 58-87) does: dequeue, normalize, skip-if-visited, crawl, handle success/failure, discover links. Could extract `processUrl()`.

### SitemapParser.discoverFromSitemap() -- ~38 lines (lines 37-76)
Tries multiple sitemap URLs, parses content, handles SiteMapIndex vs SiteMap. Linear try-catch flow. **Borderline** -- linear and readable despite length.

### Crawl4AiClient.crawl() -- ~32 lines (lines 28-60)
REST call, null checking, response extraction. Linear flow. **Borderline** -- readable as-is.

### Crawl4AiClient.buildRequest() -- ~18 lines (lines 62-80)
Map construction for Crawl4AI REST API. **No refactoring needed.**

**All other methods are well under 30 lines.**

## Spring Configuration Audit

### application.yml
All properties are actively used:
- `spring.datasource.*` -- PostgreSQL connection (used by DataSource auto-config)
- `spring.jpa.*` -- Hibernate config (ddl-auto=none, dialect, open-in-view=false)
- `spring.flyway.*` -- Migration config (enabled, locations)
- `spring.threads.virtual.enabled` -- Virtual threads (used by Spring Boot)
- `alexandria.crawl4ai.*` -- Custom props (used by Crawl4AiConfig via @Value)
- `management.endpoints.web.exposure.include` -- Actuator health endpoint

### application-web.yml
- `server.port: 8080` -- Standard
- `spring.ai.mcp.server.*` -- MCP server config for web profile

### application-stdio.yml
- `spring.main.web-application-type: none` -- No web server for stdio
- `spring.ai.mcp.server.stdio: true` -- MCP stdio mode
- `logging.*` -- Redirect to file for stdio mode

**Finding:** All properties are referenced. No orphan properties detected.

### Potential Concern
- `spring.boot.starter.aop` dependency is declared for `spring-retry`. Verify spring-retry + @Retryable is actually used somewhere in the codebase.

## Gradle Dependency Audit

### Dependencies to investigate:
1. **spring-boot-starter-aop** + **spring-retry**: Listed as dependencies. Spring-retry requires AOP for `@Retryable`. Need to verify if any class uses `@Retryable` or `@EnableRetry`.
2. **spring-boot-starter-validation**: Used by PreChunkedImporter (Jakarta Validation with `Validator` bean). Confirmed in use.
3. **spring-boot-starter-actuator**: Actuator health endpoint configured in application.yml. Confirmed in use.
4. **spring-ai-mcp-server-webmvc**: MCP server dependency. Configured in application-web.yml and application-stdio.yml. Confirmed in use.

### Investigation result: spring-retry + AOP
No `@Retryable`, `@EnableRetry`, or `RetryTemplate` usage found in the codebase. These two dependencies appear unused and are candidates for removal.

## Test Naming Inventory

### Files needing snake_case -> camelCase renaming:

| File | Tests to Rename | Example |
|------|----------------|---------|
| UrlNormalizerTest | 9 | `normalize_removes_fragment` -> `normalizeRemovesFragment` |
| SearchRequestTest | 5 | `default_maxResults_is_10` -> `defaultMaxResultsIsTen` |
| SearchServiceTest | 4 | `search_returns_result_with_correct_fields_and_passes_both_query_and_embedding` -> `searchReturnsResultWithCorrectFieldsAndPassesBothQueryAndEmbedding` |
| IngestionServiceIT | 4 | `ingest_crawl_result_produces_searchable_chunks` -> `ingestCrawlResultProducesSearchableChunks` |
| PreChunkedImporterIT | 5 | `import_valid_chunks_makes_them_searchable` -> `importValidChunksMakesThemSearchable` |
| PreChunkedImporterRollbackIT | 1 | `existing_chunks_preserved_when_embedAll_fails` -> `existingChunksPreservedWhenEmbedAllFails` |
| HybridSearchIT | 6 | `semantic_search_finds_relevant_chunks_by_meaning` -> `semanticSearchFindsRelevantChunksByMeaning` |
| EmbeddingStoreIT | 3 | `embedding_model_generates_384_dimension_vector` -> `embeddingModelGenerates384DimensionVector` |
| JpaSchemaDriftIT | 3 | `source_entity_roundtrips_against_flyway_schema` -> `sourceEntityRoundtripsAgainstFlywaySchema` |
| Crawl4AiClientIT | 3 | `crawl_returns_markdown_for_valid_url` -> `crawlReturnsMarkdownForValidUrl` |
| CrawlServiceIT | 3 | `crawlSite_crawls_at_least_one_page` -> `crawlSiteCrawlsAtLeastOnePage` |

### Files already in camelCase (no change):
- MarkdownChunkerTest (19 tests)
- LanguageDetectorTest (15 tests)

**Total: ~46 test methods to rename across 11 files.**

## Javadoc Gap Inventory

### Classes missing class-level Javadoc:
| Class | Type | Priority |
|-------|------|----------|
| Source | JPA Entity | HIGH -- core domain entity |
| DocumentChunk | JPA Entity | HIGH -- core domain entity |
| IngestionState | JPA Entity | HIGH -- tracks incremental crawl state |
| SourceStatus | Enum | MEDIUM -- values are self-explanatory but context helps |
| SourceRepository | Interface | LOW -- standard Spring Data repo |
| DocumentChunkRepository | Interface | LOW -- standard Spring Data repo |
| IngestionStateRepository | Interface | LOW -- standard Spring Data repo |
| EmbeddingConfig | @Configuration | MEDIUM -- documents infrastructure choices |
| GlobalExceptionHandler | @RestControllerAdvice | MEDIUM -- documents error mapping strategy |
| Crawl4AiConfig | @Configuration | MEDIUM -- documents REST client setup |
| Crawl4AiClient | @Service | MEDIUM -- only method-level Javadoc exists |
| CrawlResult | Record | LOW -- fields are self-explanatory |
| Crawl4AiResponse | Record | LOW -- external API mapping |
| Crawl4AiPageResult | Record | LOW -- external API mapping |
| Crawl4AiRequest | Record | LOW -- external API mapping |
| Crawl4AiLink | Record | LOW -- external API mapping |
| Crawl4AiMarkdown | Record | LOW -- external API mapping |
| AlexandriaApplication | Main class | LOW -- trivial |

### Methods missing Javadoc (on public API methods per user rules):
- Most service methods already have Javadoc
- JPA entity getters/setters: Do NOT add Javadoc (per user rules)
- `Crawl4AiClient.buildRequest()`: private, but documents complex Crawl4AI API contract -- candidate for a brief comment

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Coverage analysis | Manual line counting | `./quality.sh coverage` + JaCoCo HTML report | JaCoCo gives per-method, per-branch granularity |
| Mutation analysis | Guessing weak tests | `./quality.sh mutation --package X` | PIT precisely identifies which mutations survive |
| Bug detection | Manual review | `./quality.sh spotbugs` | SpotBugs catches EI_EXPOSE_REP pattern reliably |
| Test fixture builders | Custom framework | Simple builder class per entity | Pattern is 15-20 lines, no library needed |
| Unused dependency detection | `grep` for imports | `./gradlew dependencies --configuration compileClasspath` | Shows full dependency tree |

## Common Pitfalls

### Pitfall 1: Writing tests for coverage instead of behavior
**What goes wrong:** Tests exercise code paths but don't assert meaningful behavior. Coverage numbers go up but mutation score stays the same.
**Why it happens:** Treating coverage as a target rather than a diagnostic.
**How to avoid:** For every test, ask "if I mutate this code, will this test fail?" Run PIT after adding tests to verify.
**Warning signs:** Tests with only `assertThat(result).isNotNull()` or no meaningful assertions.

### Pitfall 2: Renaming tests breaks CI without catching it
**What goes wrong:** Renaming test methods can cause Gradle's test caching to behave unexpectedly. A renamed test might be reported as "new" while the old name shows as "removed."
**How to avoid:** Run `./quality.sh test` and `./quality.sh integration` after all renames to verify the same number of tests pass.
**Warning signs:** Test count changes after rename-only commits.

### Pitfall 3: SpotBugs false positives on Spring-managed beans
**What goes wrong:** SpotBugs reports EI_EXPOSE_REP2 on constructor injection of Spring-managed beans (EmbeddingStore, EmbeddingModel). These are false positives because Spring beans are singletons.
**How to avoid:** Add targeted suppressions to `config/spotbugs/exclude-filter.xml` for constructor parameters that are Spring beans.
**Warning signs:** Trying to make defensive copies of Spring beans in constructors.

### Pitfall 4: Defensive copy on records breaks Jackson deserialization
**What goes wrong:** Adding `List.copyOf()` in a record compact constructor can cause issues if Jackson passes null during deserialization.
**How to avoid:** Use null-safe defensive copy: `this.list = list == null ? List.of() : List.copyOf(list)` or only apply to records not used for Jackson deserialization.
**Warning signs:** NPE during JSON deserialization tests.

### Pitfall 5: Refactoring methods changes PIT mutation baseline
**What goes wrong:** Extracting methods from MarkdownChunker changes the mutation landscape. Previously surviving mutations may now be in different methods, making before/after comparison harder.
**How to avoid:** Run PIT before refactoring (baseline), refactor, run PIT again. Compare mutation SCORE not individual mutations.
**Warning signs:** Mutation count changes dramatically after refactoring.

## Code Examples

### Test Fixture Builder Pattern (for JPA entities)
```java
// Source: project convention (user decision)
public final class SourceBuilder {
    private String url = "https://docs.example.com";
    private String name = "Example Docs";

    public SourceBuilder url(String url) { this.url = url; return this; }
    public SourceBuilder name(String name) { this.name = name; return this; }

    public Source build() {
        return new Source(url, name);
    }
}

// Usage in tests:
Source source = new SourceBuilder().url("https://custom.com").build();
```

### Test Name Convention (camelCase descriptive)
```java
// BEFORE (snake_case):
void normalize_removes_fragment() { ... }
void import_valid_chunks_makes_them_searchable() { ... }

// AFTER (camelCase):
void normalizeRemovesFragment() { ... }
void importValidChunksMakesThemSearchable() { ... }
```

### Defensive Copy in Record (SpotBugs fix)
```java
// BEFORE:
public record CrawlResult(String url, String markdown, List<String> internalLinks, ...) {}

// AFTER:
public record CrawlResult(String url, String markdown, List<String> internalLinks, ...) {
    public CrawlResult {
        internalLinks = internalLinks == null ? List.of() : List.copyOf(internalLinks);
    }
}
```

### SpotBugs Exclusion for Spring Bean Injection
```xml
<!-- config/spotbugs/exclude-filter.xml -->
<!-- Spring-managed beans are singletons — storing references is safe -->
<Match>
    <Bug pattern="EI_EXPOSE_REP2"/>
    <Or>
        <Class name="dev.alexandria.search.SearchService"/>
        <Class name="dev.alexandria.ingestion.IngestionService"/>
        <Class name="dev.alexandria.ingestion.prechunked.PreChunkedImporter"/>
    </Or>
    <Method name="&lt;init&gt;"/>
</Match>
```

## Recommended Processing Order

Based on complexity, test gap severity, and the natural dependency flow:

1. **ingestion/chunking** -- Highest complexity, most surviving PIT mutations (19). Kill mutations first.
2. **crawl** -- Largest package, most files missing unit tests. Add CrawlService, Crawl4AiClient, PageDiscoveryService unit tests.
3. **search** -- Well tested but needs name harmonization.
4. **ingestion** -- Add IngestionService unit test.
5. **ingestion/prechunked** -- Add PreChunkedImporter unit test.
6. **document + source** -- Javadoc only (entities with no business logic).
7. **config** -- Javadoc only.
8. **Cross-cutting cleanup** -- Integration test consolidation, dead code, SpotBugs fixes, Spring config audit, Gradle dependency audit, test naming harmonization (can be done per-package or as final pass).

## Open Questions

1. **spring-retry + spring-boot-starter-aop usage**
   - What we know: Both dependencies are declared in build.gradle.kts but no `@Retryable`/`@EnableRetry` found in source
   - What's unclear: Were these added for a future feature or leftover from experimentation?
   - Recommendation: Remove both if no usage found after thorough grep. If they were planned for crawl retry logic, note in a comment but still remove unused deps.

2. **BaseIntegrationTest pgvector image version**
   - What we know: Uses `pgvector/pgvector:pg16` but libs.versions.toml references Testcontainers 1.21.1
   - What's unclear: Should this be pg17 (matching the CLAUDE.md mention of `pgvector/pgvector:pg17`)?
   - Recommendation: Verify which version matches production, update if needed during config audit.

## Sources

### Primary (HIGH confidence)
- Direct codebase analysis: All 33 source files and 16 test files read and analyzed
- Existing JaCoCo report: `build/reports/jacoco/test/jacocoTestReport.xml` (236/577 lines = 41%)
- Existing PIT report: `build/reports/pitest/mutations.xml` (58/113 = 51%, 20 surviving)
- Existing SpotBugs report: `build/reports/spotbugs/spotbugsMain.xml` (23 findings)
- Build configuration: `build.gradle.kts`, `gradle/libs.versions.toml`, `quality.sh`
- Spring configuration: `application.yml`, `application-web.yml`, `application-stdio.yml`

### Secondary (MEDIUM confidence)
- CLAUDE.md project documentation (conventions, architecture decisions)
- `.claude/rules/test/testing.md` (test philosophy and naming conventions)

## Metadata

**Confidence breakdown:**
- Codebase analysis: HIGH -- all files read directly, reports parsed from existing build artifacts
- Coverage gaps: HIGH -- JaCoCo XML report provides exact line counts
- Mutation gaps: HIGH -- PIT XML report lists exact surviving mutations
- SpotBugs findings: HIGH -- SpotBugs XML report provides exact bug instances
- Refactoring candidates: HIGH -- direct line count and complexity analysis
- Javadoc gaps: HIGH -- direct inspection of all files
- Gradle dependency audit: MEDIUM -- grep-based analysis, may miss indirect usage

**Research date:** 2026-02-19
**Valid until:** 2026-03-19 (stable codebase, no external dependencies researched)
