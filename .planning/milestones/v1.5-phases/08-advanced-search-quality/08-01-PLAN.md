---
phase: 08-advanced-search-quality
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/resources/db/migration/V3__source_version_column.sql
  - src/main/java/dev/alexandria/source/Source.java
  - src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java
  - src/main/java/dev/alexandria/ingestion/IngestionService.java
  - src/main/java/dev/alexandria/document/DocumentChunkRepository.java
  - src/main/java/dev/alexandria/ingestion/chunking/ContentType.java
  - src/test/java/dev/alexandria/ingestion/chunking/DocumentChunkDataTest.java
  - src/test/java/dev/alexandria/ingestion/chunking/ContentTypeTest.java
  - src/test/java/dev/alexandria/ingestion/IngestionServiceTest.java
autonomous: true
requirements:
  - CHUNK-06
  - SRCH-10

must_haves:
  truths:
    - "Source entity has a version field that persists to the database"
    - "Version label is denormalized into chunk metadata at ingestion time as 'version' key"
    - "Source name is denormalized into chunk metadata at ingestion time as 'source_name' key"
    - "Batch update of chunk metadata version works for existing chunks when version changes"
    - "ContentType.fromValue() handles case-insensitive input including 'MIXED'"
  artifacts:
    - path: "src/main/resources/db/migration/V3__source_version_column.sql"
      provides: "Version column on sources table"
      contains: "ALTER TABLE sources ADD COLUMN version"
    - path: "src/main/java/dev/alexandria/source/Source.java"
      provides: "version getter/setter on Source entity"
    - path: "src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java"
      provides: "version and sourceName fields in chunk metadata"
    - path: "src/main/java/dev/alexandria/document/DocumentChunkRepository.java"
      provides: "updateVersionMetadata and findDistinctVersions queries"
  key_links:
    - from: "src/main/java/dev/alexandria/ingestion/IngestionService.java"
      to: "DocumentChunkData"
      via: "passes version and sourceName from caller to chunk metadata"
      pattern: "version.*sourceName"
    - from: "src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java"
      to: "Metadata"
      via: "toMetadata() includes version and source_name keys"
      pattern: "put.*version.*source_name"
---

<objective>
Add version tagging to Source entity and denormalize version + source name into chunk metadata at ingestion time, providing the data foundation for all Phase 8 filtering.

Purpose: All search filters (version, source_name, content_type) require metadata to exist on chunks. This plan ensures that metadata is stored correctly so subsequent plans can filter against it.
Output: Flyway migration, Source entity with version field, DocumentChunkData with version/sourceName metadata, batch update query for existing chunks, case-insensitive ContentType parsing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-search-quality/08-RESEARCH.md
@src/main/java/dev/alexandria/source/Source.java
@src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java
@src/main/java/dev/alexandria/ingestion/IngestionService.java
@src/main/java/dev/alexandria/ingestion/chunking/ContentType.java
@src/main/java/dev/alexandria/document/DocumentChunkRepository.java
@src/main/resources/db/migration/V2__source_scope_columns.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration + Source version field + metadata denormalization</name>
  <files>
    src/main/resources/db/migration/V3__source_version_column.sql
    src/main/java/dev/alexandria/source/Source.java
    src/main/java/dev/alexandria/ingestion/chunking/DocumentChunkData.java
    src/main/java/dev/alexandria/ingestion/IngestionService.java
    src/main/java/dev/alexandria/document/DocumentChunkRepository.java
  </files>
  <action>
    1. Create Flyway migration `V3__source_version_column.sql`:
       ```sql
       ALTER TABLE sources ADD COLUMN version TEXT;
       ```

    2. Add `version` field to `Source.java`:
       - Add `@Column(name = "version") private String version;`
       - Add getter/setter: `getVersion()`, `setVersion(String version)`

    3. Extend `DocumentChunkData` record to accept optional version and sourceName:
       - Add two new nullable fields: `String version` (nullable, no requireNonNull) and `String sourceName` (nullable)
       - In `toMetadata()`: conditionally add `version` key when non-null, and `source_name` key when non-null
       - Keep existing compact constructor validation for required fields unchanged

    4. Extend `IngestionService.ingestPage()` to accept version and sourceName:
       - Add new overload: `ingestPage(String markdown, String sourceUrl, String lastUpdated, String version, String sourceName)` that passes version/sourceName through to DocumentChunkData
       - Keep existing 3-param `ingestPage()` for backward compat by delegating to the new overload with null version/sourceName
       - In `MarkdownChunker.chunk()` the chunks already carry sourceUrl -- the version/sourceName need to be set AFTER chunking. Add a private helper `enrichChunks(List<DocumentChunkData> chunks, String version, String sourceName)` that creates new DocumentChunkData records with version/sourceName set (records are immutable so must create new instances)

    5. Add native queries to `DocumentChunkRepository`:
       - `updateVersionMetadata(String sourceUrl, String version)`: native SQL using `jsonb_set(COALESCE(metadata, '{}'::jsonb), '{version}', to_jsonb(:version))` on document_chunks WHERE metadata->>'source_url' matches. Use `@Modifying @Transactional @Query(nativeQuery=true)`.
       - `updateSourceNameMetadata(String sourceUrl, String sourceName)`: same pattern for source_name key.
       - `findDistinctVersions()`: `SELECT DISTINCT metadata->>'version' FROM document_chunks WHERE metadata->>'version' IS NOT NULL` returning `List<String>`.
       - `findDistinctSourceNames()`: same pattern for source_name.

    Note: The batch update queries use source_url metadata (not source_id) for consistency with the MCP layer's string-based API -- the MCP tools identify sources by URL via `source.getUrl()`, and chunk metadata already stores `source_url` as a string key. While document_chunks does have a source_id FK column, using the metadata source_url avoids a JOIN and keeps the query self-contained against the JSONB metadata that the search layer already filters on.
  </action>
  <verify>
    `./quality.sh test` passes. Verify DocumentChunkData compiles with new fields. Verify Flyway migration file exists.
  </verify>
  <done>
    Source entity has version column. DocumentChunkData carries version+sourceName into chunk metadata. DocumentChunkRepository has batch update queries for retroactive version denormalization. IngestionService passes version/sourceName through to chunks.
  </done>
</task>

<task type="auto">
  <name>Task 2: ContentType case-insensitive parsing + unit tests for metadata changes</name>
  <files>
    src/main/java/dev/alexandria/ingestion/chunking/ContentType.java
    src/test/java/dev/alexandria/ingestion/chunking/DocumentChunkDataTest.java
    src/test/java/dev/alexandria/ingestion/chunking/ContentTypeTest.java
    src/test/java/dev/alexandria/ingestion/IngestionServiceTest.java
  </files>
  <action>
    1. Modify `ContentType.fromValue()` to be case-insensitive:
       - Change comparison to `type.value.equalsIgnoreCase(value)`
       - Also handle "MIXED" as a special case: `if ("mixed".equalsIgnoreCase(value)) return null;` -- returning null signals "no content_type filter" to the search layer (per research recommendation: MIXED is a search-only concept, not a stored enum value)
       - Alternative approach: create a separate `parseSearchFilter(String)` method that handles MIXED -> null, keeping `fromValue()` strict for deserialization. This is cleaner -- use this approach.

    2. Add/update unit tests in `ContentTypeTest.java`:
       - `fromValueHandlesCaseInsensitiveInput()`: verify "PROSE", "Prose", "prose" all return PROSE
       - `fromValueRejectsUnknownValue()`: verify exception for garbage input
       - `parseSearchFilterReturnsProse()`: "prose"/"PROSE" -> PROSE
       - `parseSearchFilterReturnsNullForMixed()`: "mixed"/"MIXED" -> null
       - `parseSearchFilterReturnsNullForNull()`: null -> null

    3. Add/update unit tests in `DocumentChunkDataTest.java`:
       - `toMetadataIncludesVersionWhenPresent()`: create DocumentChunkData with version="3.5", verify metadata has "version" key
       - `toMetadataExcludesVersionWhenNull()`: create with null version, verify no "version" key
       - `toMetadataIncludesSourceNameWhenPresent()`: verify "source_name" key in metadata
       - `toMetadataExcludesSourceNameWhenNull()`: verify no "source_name" key when null

    4. Update existing `IngestionServiceTest.java`:
       - Add test for new overloaded `ingestPage()` that verifies version/sourceName are passed through to stored TextSegments via ArgumentCaptor on embeddingStore.addAll()
       - Verify backward-compat 3-param overload still works (delegates with null version/sourceName)
  </action>
  <verify>
    `./quality.sh test` passes with all new tests. ContentType handles case-insensitive parsing. DocumentChunkData metadata round-trips version and source_name.
  </verify>
  <done>
    ContentType has `parseSearchFilter()` method handling MIXED -> null, case-insensitive matching for PROSE/CODE. DocumentChunkData metadata verified with version/sourceName. IngestionService version passthrough tested.
  </done>
</task>

</tasks>

<verification>
- `./quality.sh test` -- all unit tests pass
- `./quality.sh spotbugs` -- no new findings
- Flyway migration V3 exists and adds version column to sources
- Source entity has version getter/setter
- DocumentChunkData.toMetadata() includes version and source_name keys when non-null
- DocumentChunkRepository has batch update native queries
- ContentType handles case-insensitive parsing with MIXED -> null for search
</verification>

<success_criteria>
Version tagging infrastructure is complete: Source entity stores version, chunks carry version+source_name in JSONB metadata, batch update queries exist for retroactive denormalization, ContentType supports case-insensitive search filtering. All unit tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-search-quality/08-01-SUMMARY.md`
</output>
