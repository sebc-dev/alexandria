---
phase: 08-advanced-search-quality
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - gradle/libs.versions.toml
  - build.gradle.kts
  - src/main/java/dev/alexandria/config/EmbeddingConfig.java
  - src/main/java/dev/alexandria/search/RerankerService.java
  - src/main/java/dev/alexandria/search/SearchResult.java
  - src/main/resources/application.yml
  - docker-compose.yml
  - Dockerfile
  - src/test/java/dev/alexandria/search/RerankerServiceTest.java
autonomous: true
requirements:
  - SRCH-07

must_haves:
  truths:
    - "ScoringModel bean loads the ms-marco-MiniLM-L-6-v2 ONNX model at startup"
    - "RerankerService scores query-passage pairs and returns results sorted by reranking score"
    - "RerankerService respects maxResults limit after reranking"
    - "RerankerService respects minScore threshold, excluding low-confidence results"
    - "On ONNX model failure, RerankerService throws exception (not silent fallback)"
  artifacts:
    - path: "src/main/java/dev/alexandria/search/RerankerService.java"
      provides: "Cross-encoder reranking logic"
      min_lines: 40
    - path: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      provides: "ScoringModel bean from OnnxScoringModel"
    - path: "src/test/java/dev/alexandria/search/RerankerServiceTest.java"
      provides: "Unit tests for reranking behavior"
      min_lines: 80
  key_links:
    - from: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      to: "OnnxScoringModel"
      via: "Spring bean constructor with model and tokenizer file paths"
      pattern: "OnnxScoringModel"
    - from: "src/main/java/dev/alexandria/search/RerankerService.java"
      to: "ScoringModel"
      via: "constructor injection, scoreAll() for batch scoring"
      pattern: "scoringModel.*scoreAll"
---

<objective>
Implement cross-encoder reranking service using LangChain4j's OnnxScoringModel with the ms-marco-MiniLM-L-6-v2 model, following TDD.

Purpose: The reranker is the core quality improvement of Phase 8 -- re-scoring RRF candidates with a cross-encoder produces measurably better precision. This plan creates the reranking service and its Spring bean configuration.
Output: RerankerService with TDD-driven unit tests, ScoringModel bean, Gradle dependency, Docker/config changes for model files.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-advanced-search-quality/08-RESEARCH.md
@src/main/java/dev/alexandria/config/EmbeddingConfig.java
@src/main/java/dev/alexandria/search/SearchService.java
@src/main/java/dev/alexandria/search/SearchResult.java
@gradle/libs.versions.toml
@build.gradle.kts
@docker-compose.yml
@Dockerfile
@src/main/resources/application.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gradle dependency + model config + RerankerService TDD</name>
  <files>
    gradle/libs.versions.toml
    build.gradle.kts
    src/main/resources/application.yml
    src/main/java/dev/alexandria/config/EmbeddingConfig.java
    src/main/java/dev/alexandria/search/RerankerService.java
    src/test/java/dev/alexandria/search/RerankerServiceTest.java
  </files>
  <action>
    **Setup phase:**

    1. Add `langchain4j-onnx-scoring` dependency:
       - In `libs.versions.toml`: `langchain4j-onnx-scoring = { module = "dev.langchain4j:langchain4j-onnx-scoring", version.ref = "langchain4j-beta" }`
       - In `build.gradle.kts`: `implementation(libs.langchain4j.onnx.scoring)`

    2. Add reranker config to `application.yml`:
       ```yaml
       alexandria:
         reranker:
           model-path: ${RERANKER_MODEL_PATH:models/ms-marco-MiniLM-L-6-v2/model.onnx}
           tokenizer-path: ${RERANKER_TOKENIZER_PATH:models/ms-marco-MiniLM-L-6-v2/tokenizer.json}
       ```

    3. Add `ScoringModel` bean to `EmbeddingConfig.java`:
       ```java
       @Bean
       public ScoringModel scoringModel(
               @Value("${alexandria.reranker.model-path}") String modelPath,
               @Value("${alexandria.reranker.tokenizer-path}") String tokenizerPath) {
           return new OnnxScoringModel(modelPath, tokenizerPath);
       }
       ```
       Import `dev.langchain4j.model.scoring.ScoringModel` and `dev.langchain4j.model.scoring.onnx.OnnxScoringModel`.

    **TDD RED phase -- write failing tests first:**

    4. Create `RerankerServiceTest.java` with mock `ScoringModel`:
       - Use `@ExtendWith(MockitoExtension.class)` with `@Mock ScoringModel scoringModel`
       - Test: `reranksResultsByScore()` -- given 3 candidates with mock scores [0.8, 0.2, 0.5], reranker returns them in order [0.8, 0.5, 0.2]. Verify reranking score is set on each SearchResult.
       - Test: `respectsMaxResultsLimit()` -- given 5 candidates, maxResults=2, only top 2 by reranking score returned.
       - Test: `respectsMinScoreThreshold()` -- given 3 candidates with scores [0.8, 0.2, 0.5], minScore=0.4, only 2 results returned (0.2 excluded).
       - Test: `returnsEmptyListWhenNoCandidates()` -- empty input returns empty output.
       - Test: `propagatesScoringModelException()` -- when scoringModel.scoreAll() throws, RerankerService does NOT catch it (caller handles).
       - Test: `preservesMetadataFromOriginalResults()` -- sourceUrl, sectionPath, text are preserved through reranking.
       - Test: `minScoreNullMeansNoThreshold()` -- when minScore is null, all candidates pass regardless of score.

       Mock setup: `given(scoringModel.scoreAll(anyList(), anyString())).willReturn(Response.from(List.of(0.8, 0.2, 0.5)))` (adjust per LangChain4j API: `Response<List<Double>>`).

       RerankerService input: takes query string + List<EmbeddingMatch<TextSegment>> candidates + int maxResults + Double minScore (nullable).
       RerankerService output: returns List<SearchResult> sorted by reranking score descending, each with rerankScore field set.

    **TDD GREEN phase -- make tests pass:**

    5. Create `RerankerService.java` in `dev.alexandria.search`:
       ```java
       @Service
       public class RerankerService {
           private final ScoringModel scoringModel;

           public RerankerService(ScoringModel scoringModel) {
               this.scoringModel = scoringModel;
           }

           public List<SearchResult> rerank(String query,
                                            List<EmbeddingMatch<TextSegment>> candidates,
                                            int maxResults,
                                            Double minScore) {
               if (candidates.isEmpty()) return List.of();

               List<TextSegment> segments = candidates.stream()
                       .map(EmbeddingMatch::embedded)
                       .toList();

               Response<List<Double>> scores = scoringModel.scoreAll(segments, query);

               // Zip candidates with scores, sort by score desc, filter by minScore, limit
               return IntStream.range(0, candidates.size())
                       .mapToObj(i -> toSearchResult(candidates.get(i), scores.content().get(i)))
                       .filter(r -> minScore == null || r.rerankScore() >= minScore)
                       .sorted(Comparator.comparingDouble(SearchResult::rerankScore).reversed())
                       .limit(maxResults)
                       .toList();
           }

           private SearchResult toSearchResult(EmbeddingMatch<TextSegment> match, double rerankScore) {
               TextSegment segment = match.embedded();
               return new SearchResult(
                       segment.text(),
                       match.score(),
                       segment.metadata().getString("source_url"),
                       segment.metadata().getString("section_path"),
                       rerankScore
               );
           }
       }
       ```

    NOTE: This requires modifying `SearchResult` to add `rerankScore` field. Add it as a new field with default value (use a static factory for backward compat):
       - Add `double rerankScore` field to SearchResult record
       - Existing code that constructs SearchResult(text, score, sourceUrl, sectionPath) needs updating -- add a convenience constructor or use the canonical constructor everywhere

    **TDD REFACTOR:** Clean up, ensure no duplication, add Javadoc.
  </action>
  <verify>
    `./quality.sh test` passes including all RerankerServiceTest cases. `./gradlew compileJava` succeeds (ScoringModel bean compiles, OnnxScoringModel import resolves).
  </verify>
  <done>
    RerankerService scores and re-sorts candidates via ScoringModel, respects maxResults and minScore. SearchResult has rerankScore field. ScoringModel bean configured with file paths. Gradle dependency added. All TDD tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Docker model setup + RRF k config property</name>
  <files>
    docker-compose.yml
    Dockerfile
    src/main/resources/application.yml
    src/main/java/dev/alexandria/config/EmbeddingConfig.java
  </files>
  <action>
    1. Update `Dockerfile` to download ms-marco-MiniLM-L-6-v2 ONNX model during build:
       - In the builder stage (or a dedicated download step), add:
         ```dockerfile
         RUN mkdir -p /app/models/ms-marco-MiniLM-L-6-v2 && \
             curl -L -o /app/models/ms-marco-MiniLM-L-6-v2/model.onnx \
               https://huggingface.co/Xenova/ms-marco-MiniLM-L-6-v2/resolve/main/onnx/model.onnx && \
             curl -L -o /app/models/ms-marco-MiniLM-L-6-v2/tokenizer.json \
               https://huggingface.co/Xenova/ms-marco-MiniLM-L-6-v2/resolve/main/tokenizer.json
         ```
       - In the runtime stage, COPY the models directory:
         ```dockerfile
         COPY --from=builder /app/models /app/models
         ```

    2. Update `docker-compose.yml` app service to set model path environment variables:
       ```yaml
       environment:
         RERANKER_MODEL_PATH: /app/models/ms-marco-MiniLM-L-6-v2/model.onnx
         RERANKER_TOKENIZER_PATH: /app/models/ms-marco-MiniLM-L-6-v2/tokenizer.json
       ```

    3. Make RRF k a configurable Spring property:
       - Add to `application.yml`: `alexandria.search.rrf-k: 60`
       - In `EmbeddingConfig.embeddingStore()`: inject `@Value("${alexandria.search.rrf-k:60}") int rrfK` and use it in `.rrfK(rrfK)` builder call instead of hardcoded 60.
       - Note: per research, rrfK is store-level config only (not per-request). The MCP parameter will be accepted but a log message will note it only applies at startup.
  </action>
  <verify>
    `./gradlew compileJava` succeeds. Dockerfile syntax is valid. application.yml has reranker config section. EmbeddingConfig uses configurable rrfK.
  </verify>
  <done>
    Docker build downloads cross-encoder model files. RRF k is configurable via Spring property. Model paths configurable via environment variables with sensible defaults for both local dev and Docker.
  </done>
</task>

</tasks>

<verification>
- `./quality.sh test` -- all unit tests pass including RerankerServiceTest
- `./quality.sh spotbugs` -- no new findings
- RerankerService correctly scores and sorts candidates
- SearchResult carries rerankScore field
- ScoringModel bean configured in EmbeddingConfig
- Gradle dependency `langchain4j-onnx-scoring` resolves
- Docker build includes model download step
- application.yml has reranker paths and rrf-k config
</verification>

<success_criteria>
Cross-encoder reranking is implemented and unit-tested: RerankerService takes RRF candidates + query, scores via OnnxScoringModel, sorts by reranking score, respects maxResults and minScore threshold. Docker setup includes model files. RRF k is configurable. All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-search-quality/08-02-SUMMARY.md`
</output>
