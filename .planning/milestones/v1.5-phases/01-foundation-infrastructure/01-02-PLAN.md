---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/main/resources/db/migration/V1__create_pgvector_extension.sql
  - src/main/resources/db/migration/V2__create_sources_table.sql
  - src/main/resources/db/migration/V3__create_document_chunks_table.sql
  - src/main/resources/db/migration/V4__create_ingestion_state_table.sql
  - src/main/resources/db/migration/V5__create_indexes.sql
  - src/main/java/dev/alexandria/config/EmbeddingConfig.java
  - src/main/java/dev/alexandria/document/DocumentChunk.java
  - src/main/java/dev/alexandria/document/DocumentChunkRepository.java
  - src/main/java/dev/alexandria/source/Source.java
  - src/integrationTest/java/dev/alexandria/EmbeddingStoreIT.java
  - src/integrationTest/java/dev/alexandria/SmokeIntegrationTest.java
  - src/test/java/dev/alexandria/AlexandriaApplicationTest.java
autonomous: true

must_haves:
  truths:
    - "Flyway runs 5 migrations on startup creating pgvector extension, 3 tables, and indexes"
    - "App generates a 384-dimension float[] embedding from arbitrary text via ONNX"
    - "App stores an embedding with metadata in pgvector and retrieves it by ID"
    - "HNSW index exists on document_chunks.embedding column with vector_cosine_ops"
    - "GIN index exists for full-text search on document_chunks.text column"
    - "Integration test proves embed-store-retrieve roundtrip against real pgvector"
  artifacts:
    - path: "src/main/resources/db/migration/V1__create_pgvector_extension.sql"
      provides: "pgvector extension creation"
      contains: "CREATE EXTENSION IF NOT EXISTS vector"
    - path: "src/main/resources/db/migration/V3__create_document_chunks_table.sql"
      provides: "document_chunks table with vector(384) column"
      contains: "vector(384)"
    - path: "src/main/resources/db/migration/V5__create_indexes.sql"
      provides: "HNSW and GIN indexes"
      contains: "hnsw"
    - path: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      provides: "EmbeddingModel and EmbeddingStore Spring beans"
      exports: ["embeddingModel", "embeddingStore"]
    - path: "src/main/java/dev/alexandria/document/DocumentChunk.java"
      provides: "JPA entity for document_chunks table"
      contains: "class DocumentChunk"
    - path: "src/integrationTest/java/dev/alexandria/EmbeddingStoreIT.java"
      provides: "Integration test proving embed-store-retrieve roundtrip"
      contains: "embed_store_retrieve_roundtrip"
  key_links:
    - from: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      to: "src/main/resources/application.yml"
      via: "DataSource properties injected into PgVectorEmbeddingStore builder"
      pattern: "spring\\.datasource"
    - from: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      to: "src/main/resources/db/migration/V3__create_document_chunks_table.sql"
      via: "table name 'document_chunks' must match Flyway-created table"
      pattern: "document_chunks"
    - from: "src/integrationTest/java/dev/alexandria/EmbeddingStoreIT.java"
      to: "src/main/java/dev/alexandria/config/EmbeddingConfig.java"
      via: "Spring context wires EmbeddingModel and EmbeddingStore beans into test"
      pattern: "@Autowired"
    - from: "src/main/resources/db/migration/V5__create_indexes.sql"
      to: "src/main/resources/db/migration/V3__create_document_chunks_table.sql"
      via: "HNSW index references embedding column created in V3"
      pattern: "idx_document_chunks_embedding"
---

<objective>
Create Flyway migrations for the database schema (pgvector extension, 3 tables, HNSW+GIN indexes), configure LangChain4j ONNX embedding model and PgVectorEmbeddingStore as Spring beans, and write an integration test that proves the full embed-store-retrieve roundtrip against real pgvector via Testcontainers.

Purpose: This is the proof-of-life for Phase 1 -- the integration test proves that the foundation works end-to-end: ONNX generates embeddings, pgvector stores them, and they can be retrieved.
Output: Working Flyway migrations, embedding configuration, JPA entities, and a green integration test.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@docs/architecture.md
@build.gradle.kts
@src/main/resources/application.yml
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Flyway migrations, JPA entities, and EmbeddingConfig beans</name>
  <files>
    src/main/resources/db/migration/V1__create_pgvector_extension.sql
    src/main/resources/db/migration/V2__create_sources_table.sql
    src/main/resources/db/migration/V3__create_document_chunks_table.sql
    src/main/resources/db/migration/V4__create_ingestion_state_table.sql
    src/main/resources/db/migration/V5__create_indexes.sql
    src/main/java/dev/alexandria/config/EmbeddingConfig.java
    src/main/java/dev/alexandria/document/DocumentChunk.java
    src/main/java/dev/alexandria/document/DocumentChunkRepository.java
    src/main/java/dev/alexandria/source/Source.java
  </files>
  <action>
**Flyway Migrations** -- create `src/main/resources/db/migration/` directory with 5 SQL files:

**V1__create_pgvector_extension.sql:**
```sql
CREATE EXTENSION IF NOT EXISTS vector;
```
This MUST be the first migration. pgvector Docker image installs the extension but does NOT create it. Without this, V3 will fail with "type vector does not exist".

**V2__create_sources_table.sql:**
```sql
CREATE TABLE sources (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    url TEXT NOT NULL UNIQUE,
    name TEXT,
    status TEXT NOT NULL DEFAULT 'PENDING',
    last_crawled_at TIMESTAMPTZ,
    chunk_count INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**V3__create_document_chunks_table.sql:**
```sql
CREATE TABLE document_chunks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    embedding vector(384) NOT NULL,
    text TEXT NOT NULL,
    metadata JSONB,
    source_id UUID REFERENCES sources(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```
Use `vector(384)` NOT `halfvec(384)` -- locked decision for full precision. The foreign key to sources with CASCADE ensures removing a source removes all its chunks.

**V4__create_ingestion_state_table.sql:**
```sql
CREATE TABLE ingestion_state (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_id UUID NOT NULL REFERENCES sources(id) ON DELETE CASCADE,
    page_url TEXT NOT NULL,
    content_hash TEXT NOT NULL,
    last_ingested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(source_id, page_url)
);
```

**V5__create_indexes.sql:**
```sql
-- HNSW index for cosine similarity vector search
-- Using pgvector defaults: m=16, ef_construction=64
CREATE INDEX idx_document_chunks_embedding_hnsw
    ON document_chunks
    USING hnsw (embedding vector_cosine_ops)
    WITH (m = 16, ef_construction = 64);

-- GIN index for PostgreSQL full-text search
CREATE INDEX idx_document_chunks_text_fts
    ON document_chunks
    USING gin (to_tsvector('english', text));

-- Index for looking up chunks by source
CREATE INDEX idx_document_chunks_source_id
    ON document_chunks (source_id);

-- Index for ingestion state lookups
CREATE INDEX idx_ingestion_state_source_page
    ON ingestion_state (source_id, page_url);
```
HNSW with `vector_cosine_ops` MUST match the cosine distance operator `<=>` used by LangChain4j queries. Mismatch causes silent sequential scan (Pitfall #2 from research).

**EmbeddingConfig.java** -- create `src/main/java/dev/alexandria/config/EmbeddingConfig.java`:

```java
@Configuration
public class EmbeddingConfig {

    @Bean
    public EmbeddingModel embeddingModel() {
        return new BgeSmallEnV15QuantizedEmbeddingModel();
    }

    @Bean
    public EmbeddingStore<TextSegment> embeddingStore(DataSource dataSource) {
        // Try using the Spring-managed DataSource directly.
        // PgVectorEmbeddingStore builder supports .datasource(DataSource).
        // This shares HikariCP connection pool with JPA -- no duplicate connections.
        return PgVectorEmbeddingStore.builder()
                .datasource(dataSource)
                .table("document_chunks")
                .dimension(384)
                .createTable(false)   // Flyway manages schema
                .useIndex(false)      // HNSW created by Flyway, not IVFFlat
                .build();
    }
}
```

IMPORTANT: Use `.datasource(dataSource)` (passing the Spring DataSource bean) instead of individual `.host()/.port()/.database()` fields. Per Open Question #1 in research, the builder supports DataSource. This avoids duplicating connection config. If this fails during testing, fall back to parsing individual fields from Spring properties.

Use `.createTable(false)` -- Flyway owns the schema (anti-pattern from research).
Use `.useIndex(false)` -- HNSW is in Flyway, not LangChain4j's IVFFlat (Pitfall #1 from research).

Do NOT set `searchMode` or `rrfK` here -- those are Phase 2 concerns. Keep the config minimal for Phase 1.

**JPA Entities** -- create minimal entities for Hibernate validation:

`src/main/java/dev/alexandria/document/DocumentChunk.java`:
JPA entity mapping to `document_chunks` table. Fields: `id` (UUID, generated), `text` (String), `metadata` (String, mapped to JSONB), `sourceId` (UUID), `createdAt` (Instant). Do NOT map the `embedding` column as a JPA field -- PgVectorEmbeddingStore manages embeddings directly via its own SQL. JPA only validates the columns it maps, so unmapped columns are fine. Use `@Column(columnDefinition = ...)` only if Hibernate validation requires it. If Hibernate validation fails because of the unmapped `embedding` vector column, set `spring.jpa.hibernate.ddl-auto=none` in application.yml instead of `validate` -- Flyway is the source of truth anyway, and `none` skips validation entirely.

`src/main/java/dev/alexandria/document/DocumentChunkRepository.java`:
Spring Data JPA repository interface extending `JpaRepository<DocumentChunk, UUID>`. Empty for now.

`src/main/java/dev/alexandria/source/Source.java`:
JPA entity mapping to `sources` table. Fields: `id` (UUID, generated), `url` (String), `name` (String), `status` (String, default "PENDING"), `lastCrawledAt` (Instant), `chunkCount` (int), `createdAt` (Instant), `updatedAt` (Instant).

Use constructor injection, no field-level @Autowired (architecture.md rule). Use `@Table(name = "...")` explicitly for clarity. Follow Java Records for any value objects, but JPA entities must be classes (JPA requires no-arg constructor and mutability for managed entities).
  </action>
  <verify>
Run `./gradlew build -x integrationTest` to confirm compilation passes with new classes.
Verify all 5 migration files exist in `src/main/resources/db/migration/`.
Verify EmbeddingConfig.java exists with both bean methods.
Verify DocumentChunk.java and Source.java are valid JPA entities with @Entity annotation.
  </verify>
  <done>
5 Flyway migrations exist (V1-V5). EmbeddingConfig exposes EmbeddingModel and EmbeddingStore beans. DocumentChunk and Source JPA entities map to Flyway-created tables. Compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration test proving embed-store-retrieve roundtrip with Testcontainers pgvector</name>
  <files>
    src/integrationTest/java/dev/alexandria/EmbeddingStoreIT.java
    src/integrationTest/java/dev/alexandria/SmokeIntegrationTest.java
    src/test/java/dev/alexandria/AlexandriaApplicationTest.java
  </files>
  <action>
**Create** `src/integrationTest/java/dev/alexandria/EmbeddingStoreIT.java`:

This is the Phase 1 proof-of-life test. It proves the entire foundation works: ONNX model generates embeddings, PgVectorEmbeddingStore stores them in pgvector, and they can be retrieved.

```java
@SpringBootTest
@Testcontainers
class EmbeddingStoreIT {

    @Container
    @ServiceConnection
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(
        DockerImageName.parse("pgvector/pgvector:pg16")
            .asCompatibleSubstituteFor("postgres")
    );

    @Autowired
    EmbeddingModel embeddingModel;

    @Autowired
    EmbeddingStore<TextSegment> embeddingStore;

    @Test
    void embedding_model_generates_384_dimension_vector() {
        Response<Embedding> response = embeddingModel.embed("How to configure Spring Boot");
        Embedding embedding = response.content();

        assertThat(embedding.vector()).hasSize(384);
        // Verify vector is not all zeros (model actually computed something)
        assertThat(embedding.vector()).anySatisfy(v -> assertThat(v).isNotEqualTo(0.0f));
    }

    @Test
    void embed_store_retrieve_roundtrip() {
        // Generate embedding
        String text = "Spring Boot auto-configuration simplifies application setup";
        Embedding embedding = embeddingModel.embed(text).content();
        TextSegment segment = TextSegment.from(text);

        // Store
        String id = embeddingStore.add(embedding, segment);
        assertThat(id).isNotNull().isNotBlank();

        // Retrieve via search -- search for similar content
        EmbeddingSearchRequest searchRequest = EmbeddingSearchRequest.builder()
            .queryEmbedding(embeddingModel.embed("Spring Boot configuration").content())
            .maxResults(1)
            .build();

        EmbeddingSearchResult<TextSegment> results = embeddingStore.search(searchRequest);

        assertThat(results.matches()).hasSize(1);
        assertThat(results.matches().get(0).embedded().text())
            .isEqualTo(text);
        // Cosine similarity should be high for semantically similar queries
        assertThat(results.matches().get(0).score()).isGreaterThan(0.8);
    }

    @Test
    void flyway_migrations_created_tables_and_indexes() {
        // Verify Flyway ran successfully by checking that the app context loaded
        // (Flyway runs on startup -- if migrations fail, context won't load)
        assertThat(embeddingModel).isNotNull();
        assertThat(embeddingStore).isNotNull();
    }
}
```

Use `@ServiceConnection` (Spring Boot 3.1+ pattern) -- NOT `@DynamicPropertySource`. The `@ServiceConnection` auto-configures the DataSource from the Testcontainers PostgreSQL container. Use `.asCompatibleSubstituteFor("postgres")` because the pgvector image is compatible with PostgreSQL but has a different image name.

Import all necessary classes from:
- `dev.langchain4j.model.embedding.EmbeddingModel`
- `dev.langchain4j.data.embedding.Embedding`
- `dev.langchain4j.model.output.Response`
- `dev.langchain4j.store.embedding.EmbeddingStore`
- `dev.langchain4j.store.embedding.EmbeddingSearchRequest`
- `dev.langchain4j.store.embedding.EmbeddingSearchResult`
- `dev.langchain4j.data.segment.TextSegment`

**Update** `SmokeIntegrationTest.java` -- remove the `@Disabled` annotation added in Plan 01 and convert it to use Testcontainers:

```java
@SpringBootTest
@Testcontainers
class SmokeIntegrationTest {

    @Container
    @ServiceConnection
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(
        DockerImageName.parse("pgvector/pgvector:pg16")
            .asCompatibleSubstituteFor("postgres")
    );

    @Test
    void contextLoads() {
        // If we get here, Spring context loaded successfully with:
        // - Flyway migrations applied
        // - EmbeddingModel bean created (ONNX model loaded)
        // - EmbeddingStore bean created (pgvector connection)
        // - JPA entities validated against schema
        assertThat(true).isTrue();
    }
}
```

**Update** `AlexandriaApplicationTest.java` -- remove `@Disabled` and add Testcontainers support. This is a unit test that previously just tested context loading. Convert it to also use Testcontainers since context loading now requires a database:

Move it to use the same Testcontainers pattern. Note: this file is in the `test` source set, not `integrationTest`. The `test` source set already has `spring-boot-starter-test`. It needs Testcontainers deps too. Either:
(a) Add Testcontainers deps to the main `test` suite in build.gradle.kts, OR
(b) Simply delete this test since `SmokeIntegrationTest` already covers context loading.

Choose option (b): delete `AlexandriaApplicationTest.java`. The `SmokeIntegrationTest` in integrationTest source set already validates context loading with a real database. Having a duplicate in the unit test source set that requires a database is an anti-pattern (architecture.md: unit tests should not need infrastructure).
  </action>
  <verify>
Run `./gradlew integrationTest` and confirm all tests pass (EmbeddingStoreIT + SmokeIntegrationTest).
Specifically verify:
- `embedding_model_generates_384_dimension_vector` passes (ONNX model works)
- `embed_store_retrieve_roundtrip` passes (pgvector stores and retrieves)
- `flyway_migrations_created_tables_and_indexes` passes (Flyway runs)
- `contextLoads` passes (full Spring context with all beans)

If any test fails, read the error carefully:
- "type vector does not exist" --> V1 migration not running first
- "relation document_chunks does not exist" --> Flyway not enabled or migration path wrong
- "No qualifying bean of type EmbeddingStore" --> EmbeddingConfig not scanned
- Connection refused --> Testcontainers not starting PostgreSQL
- Hibernate validation error on `embedding` column --> switch ddl-auto to `none`

Run `./gradlew build` (full build including unit + integration tests) to confirm everything passes end-to-end.
  </verify>
  <done>
`./gradlew build` passes with all tests green. The embed-store-retrieve integration test proves: (1) ONNX model generates 384d embeddings, (2) pgvector stores them via Flyway-created schema, (3) semantic search retrieves them with high similarity score. Phase 1 success criteria #2 (embedding generation), #3 (store+retrieve), and #5 (Flyway manages schema) are verified by automated tests.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew build` passes (all unit + integration tests green)
2. Integration test `embed_store_retrieve_roundtrip` proves the full embed-store-retrieve cycle
3. Integration test `embedding_model_generates_384_dimension_vector` proves ONNX generates 384d vectors
4. Flyway migrations apply cleanly (verified by Spring context loading with `ddl-auto=validate` or `none`)
5. `docker compose up` starts all services and they reach healthy status (manual verification after both plans complete)
6. HNSW index with `vector_cosine_ops` exists on `document_chunks.embedding`
7. GIN index for FTS exists on `document_chunks.text`
</verification>

<success_criteria>
- All 5 Flyway migrations apply without errors
- EmbeddingModel bean generates 384-dimension float[] vectors from text
- PgVectorEmbeddingStore stores embeddings and retrieves them via cosine similarity search
- HNSW index (m=16, ef_construction=64, vector_cosine_ops) and GIN FTS index created by Flyway
- Integration test suite passes: embed, store, retrieve roundtrip verified against real pgvector
- `./gradlew build` green (compilation + all tests)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
