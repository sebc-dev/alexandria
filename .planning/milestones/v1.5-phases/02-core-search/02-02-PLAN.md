---
phase: 02-core-search
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/integrationTest/java/dev/alexandria/search/HybridSearchIT.java
  - src/test/java/dev/alexandria/search/SearchRequestTest.java
  - src/test/java/dev/alexandria/search/SearchServiceTest.java
autonomous: true

must_haves:
  truths:
    - "Semantic search finds chunks by meaning even when query shares no exact keywords with the stored text"
    - "Keyword search finds chunks by exact terms that appear in the stored text"
    - "Hybrid search returns results combining both semantic and keyword relevance via RRF"
    - "Every search result includes sourceUrl and sectionPath citation metadata from TextSegment metadata"
    - "Default maxResults is 10 and can be overridden to limit result count"
  artifacts:
    - path: "src/integrationTest/java/dev/alexandria/search/HybridSearchIT.java"
      provides: "Integration tests proving semantic, keyword, and hybrid search against real pgvector"
      min_lines: 80
    - path: "src/test/java/dev/alexandria/search/SearchRequestTest.java"
      provides: "Unit tests for SearchRequest validation and defaults"
      min_lines: 20
    - path: "src/test/java/dev/alexandria/search/SearchServiceTest.java"
      provides: "Unit tests for SearchService mapping logic"
      min_lines: 30
  key_links:
    - from: "src/integrationTest/java/dev/alexandria/search/HybridSearchIT.java"
      to: "src/main/java/dev/alexandria/search/SearchService.java"
      via: "Spring autowired injection"
      pattern: "@Autowired.*SearchService"
    - from: "src/integrationTest/java/dev/alexandria/search/HybridSearchIT.java"
      to: "EmbeddingStore and EmbeddingModel"
      via: "Seeds test data via Spring-injected beans"
      pattern: "embeddingStore\\.add"
---

<objective>
Prove all search modes work end-to-end with integration tests against real pgvector, plus unit tests for DTOs and service mapping logic.

Purpose: Phase 2 success criteria require demonstrable semantic search, keyword search, hybrid search, citation metadata, and configurable result count. This plan validates ALL five criteria with real database queries using manually seeded test data.

Output: HybridSearchIT (integration), SearchRequestTest (unit), SearchServiceTest (unit)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-search/02-RESEARCH.md
@.planning/phases/02-core-search/02-01-SUMMARY.md
@src/integrationTest/java/dev/alexandria/BaseIntegrationTest.java
@src/integrationTest/java/dev/alexandria/EmbeddingStoreIT.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for SearchRequest validation and SearchService mapping</name>
  <files>
    src/test/java/dev/alexandria/search/SearchRequestTest.java
    src/test/java/dev/alexandria/search/SearchServiceTest.java
  </files>
  <action>
    1. Create `src/test/java/dev/alexandria/search/SearchRequestTest.java`:
       - Test default maxResults: `new SearchRequest("query")` has maxResults == 10
       - Test custom maxResults: `new SearchRequest("query", 5)` has maxResults == 5
       - Test null query throws IllegalArgumentException with message "Query must not be blank"
       - Test blank query throws IllegalArgumentException with message "Query must not be blank"
       - Test maxResults < 1 throws IllegalArgumentException with message "maxResults must be at least 1"
       - Use `assertThatThrownBy` from AssertJ for exception tests

    2. Create `src/test/java/dev/alexandria/search/SearchServiceTest.java`:
       - Unit test with mocked EmbeddingModel and EmbeddingStore (use Mockito via @ExtendWith(MockitoExtension.class), @Mock, @InjectMocks)
       - Test `search()` method:
         - Mock `embeddingModel.embed("test query")` to return a Response containing a dummy Embedding
         - Mock `embeddingStore.search(any(EmbeddingSearchRequest.class))` to return an EmbeddingSearchResult with one EmbeddingMatch containing a TextSegment with metadata keys "source_url" and "section_path"
         - Verify the returned `List<SearchResult>` has 1 element with correct text, score, sourceUrl, sectionPath
         - Verify `embeddingStore.search()` was called with an EmbeddingSearchRequest that has both queryEmbedding AND query set (use ArgumentCaptor to capture the request and assert `.query()` is "test query" and `.queryEmbedding()` is not null)
       - Test result mapping handles null metadata gracefully (sourceUrl and sectionPath may be null for chunks without citation data)

    Use LangChain4j test utilities:
    - `Embedding.from(new float[]{...})` for creating test embeddings
    - `TextSegment.from(text, Metadata.from("source_url", "...").put("section_path", "..."))`
    - `EmbeddingMatch` constructor: `new EmbeddingMatch<>(score, embeddingId, embedding, textSegment)`
    - `EmbeddingSearchResult` constructor: `new EmbeddingSearchResult<>(List.of(match))`
    - `Response.from(embedding)` for wrapping embedding in Response
  </action>
  <verify>
    `./gradlew test` passes. Both test classes exist and all tests are green.
  </verify>
  <done>
    SearchRequest validation tested (null, blank, default maxResults, custom maxResults). SearchService mapping tested with mocks (embedding, store delegation, DTO mapping, argument capture proving both query and queryEmbedding are passed).
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests proving semantic, keyword, and hybrid search with citation metadata</name>
  <files>
    src/integrationTest/java/dev/alexandria/search/HybridSearchIT.java
  </files>
  <action>
    Create `src/integrationTest/java/dev/alexandria/search/HybridSearchIT.java` extending `BaseIntegrationTest`:

    **Test data setup (@BeforeEach):**
    - Call `embeddingStore.removeAll()` to clean state between tests
    - Seed 4-6 diverse TextSegments with metadata, stored via embeddingStore.add():

    Chunk A (routing/semantic): "To configure routing in Spring Boot, use @RequestMapping annotation on controller methods. Routes map HTTP methods and URL patterns to handler methods."
      metadata: source_url="https://docs.spring.io/routing", section_path="Web > Routing > Basics"

    Chunk B (routing/keyword): "The RouterModule in Angular provides directives and services for in-app navigation. Import RouterModule.forRoot(routes) in your AppModule."
      metadata: source_url="https://angular.dev/guide/routing", section_path="Guide > Routing > Setup"

    Chunk C (unrelated/database): "PostgreSQL supports JSONB columns for storing semi-structured data. Use the -> operator to access JSON fields."
      metadata: source_url="https://postgresql.org/docs/jsonb", section_path="Data Types > JSONB"

    Chunk D (code example): "```java\n@RestController\npublic class UserController {\n    @GetMapping(\"/users\")\n    public List<User> getUsers() { return userService.findAll(); }\n}\n```"
      metadata: source_url="https://docs.spring.io/rest", section_path="Web > REST > Controllers", content_type="code"

    For each chunk: embed via embeddingModel.embed(segment), then embeddingStore.add(embedding, segment).

    **Tests (autowire SearchService, EmbeddingStore, EmbeddingModel):**

    1. `semantic_search_finds_relevant_chunks_by_meaning()`:
       - Search: "how to set up URL routing" (shares meaning with chunks A and B, not exact terms)
       - Assert: results are not empty, top results contain routing-related chunks (A or B), PostgreSQL chunk (C) should NOT be in top 2
       - SRCH-01: Proves semantic/vector search works

    2. `keyword_search_finds_chunks_with_exact_terms()`:
       - Search: "RouterModule" (exact term only in chunk B)
       - Assert: results contain chunk B, chunk B appears with non-zero score
       - SRCH-02: Proves keyword/full-text search works
       - NOTE: This test validates the V2 GIN index fix. If the index expression doesn't match, this query will still work but via sequential scan (which is fine for test data size, but proves the keyword path is active)

    3. `hybrid_search_combines_vector_and_keyword_results()`:
       - Search: "RouterModule routing configuration" (has both semantic meaning and exact keyword "RouterModule")
       - Assert: chunk B (Angular RouterModule) should rank highly because it matches BOTH semantically AND by keyword
       - Assert: results include at least 2 items (proving multiple sources contribute)
       - SRCH-03: Proves hybrid RRF fusion works

    4. `search_results_include_citation_metadata()`:
       - Search: "PostgreSQL JSONB" (should match chunk C)
       - Assert: top result has sourceUrl == "https://postgresql.org/docs/jsonb"
       - Assert: top result has sectionPath == "Data Types > JSONB"
       - Assert: top result text is not null or blank
       - Assert: top result score is > 0
       - SRCH-05: Proves citation metadata round-trips correctly

    5. `search_respects_max_results_parameter()`:
       - Search with maxResults=2: any query that would match all chunks
       - Assert: results.size() <= 2
       - Search with default (10): same query
       - Assert: results.size() <= 10 (and >= number of seeded chunks, since we have 4)
       - SRCH-06: Proves configurable result count

    6. `search_with_no_matching_content_returns_empty_or_low_score_results()`:
       - Search: "quantum entanglement particle physics" (completely unrelated to all seeded data)
       - Assert: either results are empty OR all results have very low scores (< 0.3)
       - Proves the search doesn't return false positives

    **Important implementation notes:**
    - Autowire: `SearchService searchService`, `EmbeddingStore<TextSegment> embeddingStore`, `EmbeddingModel embeddingModel`
    - Use AssertJ for all assertions
    - The integration test exercises the FULL stack: ONNX embedding -> PgVectorEmbeddingStore with HYBRID mode -> PostgreSQL pgvector + GIN index -> RRF fusion -> SearchService DTO mapping
    - Tests may need lenient assertions on exact ranking (e.g., "routing chunks appear in top 3" not "chunk A is exactly first") because embedding model behavior and RRF scoring are somewhat non-deterministic
  </action>
  <verify>
    `./gradlew integrationTest` passes. HybridSearchIT has 6 tests, all green. Tests cover: semantic search (SRCH-01), keyword search (SRCH-02), hybrid search (SRCH-03), citation metadata (SRCH-05), configurable result count (SRCH-06), and no false positives.
  </verify>
  <done>
    All 5 Phase 2 success criteria verified by integration tests:
    (1) Semantic search finds chunks by meaning via cosine similarity
    (2) Keyword search finds chunks by exact terms via full-text search
    (3) Hybrid search combines both via RRF
    (4) Every result includes sourceUrl and sectionPath citation metadata
    (5) maxResults is configurable with default of 10
  </done>
</task>

</tasks>

<verification>
- `./gradlew test` passes (unit tests for SearchRequest and SearchService)
- `./gradlew integrationTest` passes (HybridSearchIT proves all search modes)
- `./gradlew check` passes (full build including both test suites)
- HybridSearchIT seeds test data with metadata and verifies citation round-trip
- SearchServiceTest verifies both queryEmbedding AND query are passed to EmbeddingSearchRequest
- All 5 ROADMAP success criteria for Phase 2 are covered by at least one test
</verification>

<success_criteria>
All search modes proven working via tests: semantic search matches by meaning, keyword search matches by exact terms, hybrid combines both via RRF, citation metadata (sourceUrl, sectionPath) round-trips correctly, and maxResults defaults to 10 and is configurable.
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-search/02-02-SUMMARY.md`
</output>
